{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#kn-sock","title":"kn-sock","text":"<p>A simplified socket programming toolkit for Python.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>TCP/UDP Messaging: Supports both synchronous and asynchronous communication.</li> <li>JSON Socket Communication: Easily send and receive JSON data over sockets.</li> <li>File Transfer over TCP: Transfer files between clients and servers.</li> <li>Threaded/Multi-Client Support: Handle multiple clients concurrently.</li> <li>Command-Line Interface: Simple CLI for quick socket operations.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install kn-sock\n</code></pre>"},{"location":"#usage","title":"Usage","text":""},{"location":"#tcp-messaging","title":"TCP Messaging","text":""},{"location":"#synchronous-tcp-server","title":"Synchronous TCP Server","text":"<pre><code>from kn_sock import start_tcp_server\n\ndef handle_tcp_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming TCP messages.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    client_socket.sendall(b\"Message received\")\n\nstart_tcp_server(8080, handle_tcp_message)\n</code></pre>"},{"location":"#synchronous-tcp-client","title":"Synchronous TCP Client","text":"<pre><code>from kn_sock import send_tcp_message\n\nsend_tcp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"#asynchronous-tcp-server","title":"Asynchronous TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_tcp_server\n\nasync def handle_tcp_message(data, addr, writer):\n    \"\"\"\n    Handle incoming TCP messages asynchronously.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        writer (asyncio.StreamWriter): The writer object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n    writer.write(b\"Message received\")\n    await writer.drain()\n\nasyncio.run(start_async_tcp_server(8080, handle_tcp_message))\n</code></pre>"},{"location":"#asynchronous-tcp-client","title":"Asynchronous TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_tcp_message_async\n\nasyncio.run(send_tcp_message_async(\"localhost\", 8080, \"Hello, World!\"))\n</code></pre>"},{"location":"#secure-tcp-ssltls","title":"Secure TCP (SSL/TLS)","text":"<p><code>kn_sock</code> supports secure TCP communication using SSL/TLS, both in code and via the CLI.</p>"},{"location":"#synchronous-secure-tcp-server","title":"Synchronous Secure TCP Server","text":"<pre><code>from kn_sock import start_ssl_tcp_server\n\ndef handle_secure(data, addr, client_socket):\n    print(f\"Received from {addr}: {data.decode()}\")\n    client_socket.sendall(b\"Secure response\")\n\nstart_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\",\n    cafile=\"ca.crt\",  # Optional, for client cert verification\n    require_client_cert=True  # For mutual TLS\n)\n</code></pre>"},{"location":"#synchronous-secure-tcp-client","title":"Synchronous Secure TCP Client","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\nsend_ssl_tcp_message(\n    \"localhost\", 8443, \"Hello Secure\",\n    cafile=\"ca.crt\",  # Optional, for server verification\n    certfile=\"client.crt\", keyfile=\"client.key\"  # For mutual TLS\n)\n</code></pre>"},{"location":"#asynchronous-secure-tcp-server","title":"Asynchronous Secure TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_ssl_tcp_server\n\nasync def handle_secure(data, addr, writer):\n    print(f\"Received from {addr}: {data.decode()}\")\n    writer.write(b\"Secure response\")\n    await writer.drain()\n\nasyncio.run(start_async_ssl_tcp_server(\n    8443,\n    handle_secure,\n    certfile=\"server.crt\",\n    keyfile=\"server.key\"\n))\n</code></pre>"},{"location":"#asynchronous-secure-tcp-client","title":"Asynchronous Secure TCP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_ssl_tcp_message_async\n\nasyncio.run(send_ssl_tcp_message_async(\n    \"localhost\", 8443, \"Hello Secure\"\n))\n</code></pre>"},{"location":"#cli-usage","title":"CLI Usage","text":"<pre><code># Start a secure server\nkn-sock run-ssl-tcp-server 8443 server.crt server.key --cafile ca.crt --require-client-cert\n\n# Send a secure message\nkn-sock send-ssl-tcp localhost 8443 \"Hello Secure\" --cafile ca.crt --certfile client.crt --keyfile client.key\n</code></pre> <p>Note: You must have valid certificate and key files. For testing, you can generate self-signed certificates using OpenSSL.</p>"},{"location":"#tcp-connection-pooling","title":"TCP Connection Pooling","text":"<p><code>kn_sock</code> provides a TCPConnectionPool for efficient client-side connection reuse. This reduces connection overhead for frequent requests.</p>"},{"location":"#basic-usage-plain-tcp","title":"Basic Usage (Plain TCP)","text":"<pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool('localhost', 8080, max_size=5, idle_timeout=30)\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello\")\n    data = conn.recv(1024)\n    print(data)\n\npool.closeall()  # Clean up all connections\n</code></pre>"},{"location":"#secure-usage-ssltls","title":"Secure Usage (SSL/TLS)","text":"<pre><code>from kn_sock import TCPConnectionPool\n\npool = TCPConnectionPool(\n    'localhost', 8443, max_size=5, idle_timeout=30,\n    ssl=True, cafile=\"ca.crt\", certfile=\"client.crt\", keyfile=\"client.key\", verify=True\n)\nwith pool.connection() as conn:\n    conn.sendall(b\"Hello Secure\")\n    data = conn.recv(1024)\n    print(data)\n\npool.closeall()\n</code></pre> <ul> <li><code>max_size</code>: Maximum number of pooled connections.</li> <li><code>idle_timeout</code>: Seconds before idle connections are closed.</li> <li><code>ssl</code>, <code>cafile</code>, <code>certfile</code>, <code>keyfile</code>, <code>verify</code>: SSL/TLS options.</li> </ul>"},{"location":"#udp-messaging","title":"UDP Messaging","text":""},{"location":"#synchronous-udp-server","title":"Synchronous UDP Server","text":"<pre><code>from kn_sock import start_udp_server\n\ndef handle_udp_message(data, addr, server_socket):\n    \"\"\"\n    Handle incoming UDP messages.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        server_socket (socket.socket): The server socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n\nstart_udp_server(8080, handle_udp_message)\n</code></pre>"},{"location":"#synchronous-udp-client","title":"Synchronous UDP Client","text":"<pre><code>from kn_sock import send_udp_message\n\nsend_udp_message(\"localhost\", 8080, \"Hello, World!\")\n</code></pre>"},{"location":"#asynchronous-udp-server","title":"Asynchronous UDP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_udp_server_async\n\nasync def handle_udp_message(data, addr, transport):\n    \"\"\"\n    Handle incoming UDP messages asynchronously.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        transport (asyncio.DatagramTransport): The transport object for the client.\n    \"\"\"\n    print(f\"Received from {addr}: {data.decode('utf-8')}\")\n\nasyncio.run(start_udp_server_async(8080, handle_udp_message))\n</code></pre>"},{"location":"#asynchronous-udp-client","title":"Asynchronous UDP Client","text":"<pre><code>import asyncio\nfrom kn_sock import send_udp_message_async\n\nasyncio.run(send_udp_message_async(\"localhost\", 8080, \"Hello, World!\"))\n</code></pre>"},{"location":"#json-socket-communication","title":"JSON Socket Communication","text":""},{"location":"#json-server","title":"JSON Server","text":"<pre><code>from kn_sock import start_json_server\n\ndef handle_json_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming JSON messages.\n\n    Args:\n        data (dict): The JSON data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    print(f\"Received from {addr}: {data}\")\n    client_socket.sendall(b'{\"status\": \"received\"}')\n\nstart_json_server(8080, handle_json_message)\n</code></pre>"},{"location":"#json-client","title":"JSON Client","text":"<pre><code>from kn_sock import send_json\n\nsend_json(\"localhost\", 8080, {\"message\": \"Hello, World!\"})\n</code></pre>"},{"location":"#file-transfer-over-tcp","title":"File Transfer over TCP","text":""},{"location":"#file-server","title":"File Server","text":"<pre><code>from kn_sock import start_file_server\n\nstart_file_server(8080, \"/path/to/save/directory\")\n</code></pre>"},{"location":"#file-client","title":"File Client","text":"<pre><code>from kn_sock import send_file\n\nsend_file(\"localhost\", 8080, \"path/to/your/file.txt\")\n</code></pre>"},{"location":"#async-file-transfer","title":"Async File Transfer","text":"<pre><code>from kn_sock import start_file_server_async, send_file_async\nimport asyncio\n\n# Async server\nasyncio.run(start_file_server_async(8080, \"/path/to/save/directory\"))\n\n# Async client\nasyncio.run(send_file_async(\"localhost\", 8080, \"path/to/your/file.txt\"))\n</code></pre>"},{"location":"#live-videoaudio-streaming-multi-video-selection","title":"Live Video/Audio Streaming (Multi-Video Selection)","text":"<p>The <code>kn_sock</code> library supports live video and audio streaming from one or more video files to multiple clients, with adaptive bitrate and smooth playback.</p> <p>Note: For best compatibility, use video files encoded as mp4 (H.264). Some formats (e.g., AV1) may not be supported by your OpenCV/FFmpeg installation.</p>"},{"location":"#features_1","title":"Features","text":"<ul> <li>Multi-Video Support: Server can offer multiple videos; clients select which to play</li> <li>Adaptive Bitrate: Server adjusts video quality per client based on buffer feedback</li> <li>Jitter Buffer: Client-side buffering for smooth video/audio playback</li> <li>Robust Audio Protocol: Audio stream uses magic numbers and timestamps for resynchronization</li> <li>Real-time Feedback: Client sends buffer status to server for quality adjustment</li> </ul>"},{"location":"#live-stream-server-python","title":"Live Stream Server (Python)","text":"<pre><code>from kn_sock import start_live_stream\n\n# Start a live stream server with multiple videos\nstart_live_stream(9000, [\"video1.mp4\", \"video2.mp4\", \"video3.mp4\"])\n\n# Or with a single video\nstart_live_stream(9000, [\"video.mp4\"])\n</code></pre>"},{"location":"#live-stream-client-python","title":"Live Stream Client (Python)","text":"<pre><code>from kn_sock import connect_to_live_server\n\n# Connect to a live stream server\nconnect_to_live_server(\"192.168.1.10\", 9000)\n</code></pre>"},{"location":"#advanced-usage-with-livestreamserverlivestreamclient","title":"Advanced Usage with LiveStreamServer/LiveStreamClient","text":"<pre><code>from kn_sock.live_stream import LiveStreamServer, LiveStreamClient\n\n# Server with custom configuration\nserver = LiveStreamServer(\n    video_paths=[\"video1.mp4\", \"video2.mp4\"],\n    host='0.0.0.0',\n    video_port=8000,\n    audio_port=8001,\n    control_port=8010\n)\nserver.start()\n\n# Client with custom buffer settings\nclient = LiveStreamClient(\n    host='127.0.0.1',\n    video_port=8000,\n    audio_port=8001,\n    control_port=8010,\n    video_buffer_ms=200,  # 200ms video buffer\n    audio_buffer_ms=100,  # 100ms audio buffer\n    video_fps=30\n)\nclient.start()\n</code></pre>"},{"location":"#live-streaming-via-cli","title":"Live Streaming via CLI","text":"<ul> <li>Start a live stream server with multiple videos:</li> </ul> <pre><code>kn-sock run-live-server 9000 video1.mp4 video2.mp4 video3.mp4\n# Optional: --host 0.0.0.0 --audio-port 9001\n</code></pre> <ul> <li>Connect as a live stream client:</li> </ul> <pre><code>kn-sock connect-live-server 192.168.1.10 9000\n# Optional: --audio-port 9001\n</code></pre>"},{"location":"#how-it-works","title":"How It Works","text":"<ol> <li>Server Setup: Server extracts audio from video files using FFmpeg</li> <li>Client Connection: Client connects to video, audio, and control ports</li> <li>Video Selection: If multiple videos are available, client is prompted to select one</li> <li>Streaming: Server streams video frames and audio chunks with timestamps</li> <li>Adaptive Quality: Client sends buffer feedback; server adjusts JPEG quality (40-90)</li> <li>Smooth Playback: Client uses jitter buffers to smooth out network irregularities</li> </ol>"},{"location":"#protocol-details","title":"Protocol Details","text":"<ul> <li>Video Protocol: Each frame is sent as <code>[8-byte timestamp][4-byte length][JPEG data]</code></li> <li>Audio Protocol: Each chunk is sent as <code>[4-byte magic][8-byte timestamp][4-byte length][audio data]</code></li> <li>Control Protocol: Client sends JSON feedback: <code>{\"buffer_level\": 0.2}</code></li> </ul>"},{"location":"#requirements","title":"Requirements","text":"<ul> <li>Python Dependencies: <code>opencv-python</code>, <code>pyaudio</code>, <code>numpy</code></li> <li>System Dependencies: <code>ffmpeg</code> (for audio extraction)</li> <li>Network: TCP ports for video, audio, and control streams</li> </ul>"},{"location":"#websocket-support","title":"WebSocket Support","text":"<p>kn_sock provides a minimal WebSocket server and client for real-time, bidirectional communication (e.g., chat, dashboards, live updates).</p> <ul> <li>Use <code>start_websocket_server(host, port, handler_func, ...)</code> to start a WebSocket server.</li> <li>Use <code>connect_websocket(host, port, ...)</code> to connect as a client.</li> </ul>"},{"location":"#example-websocket-echo-server","title":"Example: WebSocket Echo Server","text":"<pre><code>from kn_sock import start_websocket_server\nimport threading\n\ndef echo_handler(ws):\n    print(f\"[WebSocket][SERVER] Client connected: {ws.addr}\")\n    try:\n        while ws.open:\n            msg = ws.recv()\n            if not msg:\n                break\n            ws.send(f\"Echo: {msg}\")\n    finally:\n        ws.close()\n\nshutdown_event = threading.Event()\nserver_thread = threading.Thread(\n    target=start_websocket_server,\n    args=(\"127.0.0.1\", 8765, echo_handler),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n# ... trigger shutdown_event as needed ...\n</code></pre>"},{"location":"#example-websocket-client","title":"Example: WebSocket Client","text":"<pre><code>from kn_sock import connect_websocket\nws = connect_websocket(\"127.0.0.1\", 8765)\nws.send(\"Hello WebSocket!\")\nreply = ws.recv()\nprint(f\"Received: {reply}\")\nws.close()\n</code></pre> <p>Note: This implementation supports text frames only (no binary, no extensions, no SSL for browsers yet). Suitable for Python-to-Python or custom client/server use.</p>"},{"location":"#httphttps-client-support","title":"HTTP/HTTPS Client Support","text":"<p>kn_sock provides simple HTTP and HTTPS client helpers for quick requests without external libraries.</p> <ul> <li><code>http_get(host, port=80, path='/', headers=None)</code></li> <li><code>http_post(host, port=80, path='/', data='', headers=None)</code></li> <li><code>https_get(host, port=443, path='/', headers=None, cafile=None)</code></li> <li><code>https_post(host, port=443, path='/', data='', headers=None, cafile=None)</code></li> </ul>"},{"location":"#example-http-getpost","title":"Example: HTTP GET/POST","text":"<pre><code>from kn_sock import http_get, http_post\n\nbody = http_get(\"example.com\", 80, \"/\")\nprint(body)\n\nbody = http_post(\"httpbin.org\", 80, \"/post\", data=\"foo=bar&amp;baz=qux\")\nprint(body)\n</code></pre>"},{"location":"#example-https-getpost","title":"Example: HTTPS GET/POST","text":"<pre><code>from kn_sock import https_get, https_post\n\nbody = https_get(\"example.com\", 443, \"/\")\nprint(body)\n\nbody = https_post(\"httpbin.org\", 443, \"/post\", data=\"foo=bar&amp;baz=qux\")\nprint(body)\n</code></pre> <p>Note: These helpers do not support redirects, chunked encoding, or cookies. For advanced HTTP features, use a full HTTP library.</p>"},{"location":"#http-server","title":"HTTP Server","text":"<p>kn_sock provides a minimal HTTP server for serving static files and handling simple API routes.</p> <ul> <li>Use <code>start_http_server(host, port, static_dir=None, routes=None, shutdown_event=None)</code> to start the server.</li> <li><code>static_dir</code>: Directory to serve files from (e.g., index.html).</li> <li><code>routes</code>: Dict mapping (method, path) to handler functions. Handler signature: (request, client_socket).</li> <li><code>shutdown_event</code>: For graceful shutdown.</li> </ul>"},{"location":"#example-static-file-and-route-handlers","title":"Example: Static File and Route Handlers","text":"<pre><code>from kn_sock import start_http_server\nimport threading\nimport os\n\ndef hello_route(request, client_sock):\n    client_sock.sendall(b\"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: 5\\r\\n\\r\\nHello\")\n\ndef echo_post(request, client_sock):\n    body = request['raw'].split(b'\\r\\n\\r\\n', 1)[-1]\n    resp = b\"HTTP/1.1 200 OK\\r\\nContent-Type: text/plain\\r\\nContent-Length: \" + str(len(body)).encode() + b\"\\r\\n\\r\\n\" + body\n    client_sock.sendall(resp)\n\nos.makedirs(\"static\", exist_ok=True)\nwith open(\"static/index.html\", \"w\") as f:\n    f.write(\"&lt;h1&gt;Hello from static file!&lt;/h1&gt;\")\nroutes = {\n    (\"GET\", \"/hello\"): hello_route,\n    (\"POST\", \"/echo\"): echo_post,\n}\nshutdown_event = threading.Event()\nserver_thread = threading.Thread(\n    target=start_http_server,\n    args=(\"127.0.0.1\", 8080),\n    kwargs={\"static_dir\": \"static\", \"routes\": routes, \"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n# ... trigger shutdown_event as needed ...\n</code></pre> <p>Note: This server is for prototyping and simple use cases. For production, use a full-featured HTTP server.</p>"},{"location":"#publishsubscribe-pubsub","title":"Publish/Subscribe (Pub/Sub)","text":"<p>kn_sock provides a simple TCP-based pub/sub server and client for topic-based messaging.</p> <ul> <li>Use <code>start_pubsub_server(port, handler_func=None, host='0.0.0.0', shutdown_event=None)</code> to start the server.</li> <li>Use <code>PubSubClient(host, port)</code> for the client. Methods: <code>subscribe(topic)</code>, <code>unsubscribe(topic)</code>, <code>publish(topic, message)</code>, <code>recv(timeout=None)</code>.</li> </ul>"},{"location":"#example-pubsub-server","title":"Example: Pub/Sub Server","text":"<pre><code>from kn_sock import start_pubsub_server\nimport threading\n\nshutdown_event = threading.Event()\nserver_thread = threading.Thread(\n    target=start_pubsub_server,\n    args=(9000,),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n# ... trigger shutdown_event as needed ...\n</code></pre>"},{"location":"#example-pubsub-client","title":"Example: Pub/Sub Client","text":"<pre><code>from kn_sock import PubSubClient\nclient = PubSubClient(\"127.0.0.1\", 9000)\nclient.subscribe(\"news\")\nclient.publish(\"news\", \"Hello, subscribers!\")\nmsg = client.recv(timeout=2)\nprint(msg)\nclient.close()\n</code></pre> <p>Protocol: All messages are JSON lines. Actions: <code>subscribe</code>, <code>unsubscribe</code>, <code>publish</code>. Server broadcasts published messages to all subscribers of a topic.</p> <p>Use cases: Chat rooms, notifications, real-time data updates, event-driven apps.</p>"},{"location":"#remote-procedure-call-rpc","title":"Remote Procedure Call (RPC)","text":"<p>kn_sock provides a simple TCP-based JSON-RPC server and client for remote function calls.</p> <ul> <li>Use <code>start_rpc_server(port, register_funcs, host='0.0.0.0', shutdown_event=None)</code> to start the server.</li> <li>Use <code>RPCClient(host, port)</code> for the client. Method: <code>call(function, *args, **kwargs)</code>.</li> </ul>"},{"location":"#example-rpc-server","title":"Example: RPC Server","text":"<pre><code>from kn_sock import start_rpc_server\nimport threading\n\ndef add(a, b):\n    return a + b\n\ndef echo(msg):\n    return msg\n\nfuncs = {\"add\": add, \"echo\": echo}\nshutdown_event = threading.Event()\nserver_thread = threading.Thread(\n    target=start_rpc_server,\n    args=(9001, funcs),\n    kwargs={\"shutdown_event\": shutdown_event},\n    daemon=True\n)\nserver_thread.start()\n# ... trigger shutdown_event as needed ...\n</code></pre>"},{"location":"#example-rpc-client","title":"Example: RPC Client","text":"<pre><code>from kn_sock import RPCClient\nclient = RPCClient(\"127.0.0.1\", 9001)\nprint(client.call(\"add\", 2, 3))\nprint(client.call(\"echo\", msg=\"Hello!\"))\nclient.close()\n</code></pre> <p>Protocol: All requests and responses are JSON lines. Requests: <code>{method, params, kwargs}</code>. Responses: <code>{result}</code> or <code>{error}</code>.</p> <p>Use cases: Distributed computing, remote control, microservices, automation.</p>"},{"location":"#command-line-interface","title":"Command-Line Interface","text":"<p>The <code>kn-sock</code> library comes with a simple CLI for quick socket operations. You can use the following commands:</p> <ul> <li>Send TCP Message:</li> </ul> <pre><code>kn-sock send-tcp localhost 8080 \"Hello, World!\"\n</code></pre> <ul> <li>Start TCP Server:</li> </ul> <pre><code>kn-sock run-tcp-server 8080\n</code></pre> <ul> <li>Send UDP Message:</li> </ul> <pre><code>kn-sock send-udp localhost 8080 \"Hello, World!\"\n</code></pre> <ul> <li>Start UDP Server:</li> </ul> <pre><code>kn-sock run-udp-server 8080\n</code></pre> <ul> <li>Send File:</li> </ul> <pre><code>kn-sock send-file localhost 8080 path/to/your/file.txt\n</code></pre> <ul> <li>Start File Server:</li> </ul> <pre><code>kn-sock run-file-server 8080 /path/to/save/directory\n</code></pre>"},{"location":"#decorators","title":"Decorators","text":"<p>The <code>.decorators</code> module provides useful decorators to enhance your socket handlers.</p>"},{"location":"#log_exceptions","title":"<code>log_exceptions</code>","text":"<p>Logs exceptions and optionally re-raises them.</p> <pre><code>from kn_sock.decorators import log_exceptions\n\n@log_exceptions(raise_error=True)\ndef handle_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming messages with exception logging.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    # Your message handling code here\n    pass\n</code></pre>"},{"location":"#retry","title":"<code>retry</code>","text":"<p>Retries a function upon failure, with a delay between attempts.</p> <pre><code>from kn_sock.decorators import retry\n\n@retry(retries=3, delay=1.0, exceptions=(Exception,))\ndef handle_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming messages with retry logic.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    # Your message handling code here\n    pass\n</code></pre>"},{"location":"#measure_time","title":"<code>measure_time</code>","text":"<p>Measures and prints the execution time of the wrapped function.</p> <pre><code>from kn_sock.decorators import measure_time\n\n@measure_time\ndef handle_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming messages with execution time measurement.\n\n    Args:\n        data (bytes): The data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    # Your message handling code here\n    pass\n</code></pre>"},{"location":"#ensure_json_input","title":"<code>ensure_json_input</code>","text":"<p>Validates that the first argument is a valid JSON object (dict or str). Raises <code>InvalidJSONError</code> otherwise.</p> <pre><code>from kn_sock.decorators import ensure_json_input\n\n@ensure_json_input\ndef handle_json_message(data, addr, client_socket):\n    \"\"\"\n    Handle incoming JSON messages with input validation.\n\n    Args:\n        data (dict): The JSON data received from the client.\n        addr (tuple): The address of the client.\n        client_socket (socket.socket): The client socket.\n    \"\"\"\n    # Your JSON message handling code here\n    pass\n</code></pre>"},{"location":"#utilities","title":"Utilities","text":"<p>The <code>.utils</code> module provides various utility functions to assist with socket programming.</p>"},{"location":"#network-utilities","title":"Network Utilities","text":""},{"location":"#get_free_port","title":"<code>get_free_port</code>","text":"<p>Finds a free port for TCP binding (useful for tests).</p> <pre><code>from kn_sock.utils import get_free_port\n\nport = get_free_port()\nprint(f\"Free port: {port}\")\n</code></pre>"},{"location":"#get_local_ip","title":"<code>get_local_ip</code>","text":"<p>Returns the local IP address of the current machine.</p> <pre><code>from kn_sock.utils import get_local_ip\n\nip = get_local_ip()\nprint(f\"Local IP: {ip}\")\n</code></pre>"},{"location":"#file-utilities","title":"File Utilities","text":""},{"location":"#chunked_file_reader","title":"<code>chunked_file_reader</code>","text":"<p>Yields file data in chunks for streaming transfer.</p> <pre><code>from kn_sock.utils import chunked_file_reader\n\nfor chunk in chunked_file_reader(\"path/to/your/file.txt\"):\n    # Process each chunk\n    pass\n</code></pre>"},{"location":"#recv_all","title":"<code>recv_all</code>","text":"<p>Receives exactly <code>total_bytes</code> from a socket.</p> <pre><code>from kn_sock.utils import recv_all\n\ndata = recv_all(client_socket, total_bytes)\n</code></pre>"},{"location":"#progress-display","title":"Progress Display","text":""},{"location":"#print_progress","title":"<code>print_progress</code>","text":"<p>Prints file transfer progress in percentage.</p> <pre><code>from kn_sock.utils import print_progress\n\nprint_progress(received_bytes, total_bytes)\n</code></pre>"},{"location":"#json-utility","title":"JSON Utility","text":""},{"location":"#is_valid_json","title":"<code>is_valid_json</code>","text":"<p>Checks whether a string is valid JSON.</p> <pre><code>from kn_sock.utils import is_valid_json\n\nif is_valid_json(json_string):\n    print(\"Valid JSON\")\nelse:\n    print(\"Invalid JSON\")\n</code></pre>"},{"location":"#errors","title":"Errors","text":"<p>The <code>.errors</code> module defines custom exceptions for the <code>kn_sock</code> library.</p>"},{"location":"#easysocketerror","title":"<code>EasySocketError</code>","text":"<p>Base exception for all <code>kn_sock</code> errors.</p> <pre><code>from kn_sock.errors import EasySocketError\n\ntry:\n    # Your code here\n    pass\nexcept EasySocketError as e:\n    print(f\"EasySocketError: {e}\")\n</code></pre>"},{"location":"#connection-related-errors","title":"Connection-related Errors","text":""},{"location":"#connectiontimeouterror","title":"<code>ConnectionTimeoutError</code>","text":"<p>Raised when a connection or read/write operation times out.</p> <pre><code>from kn_sock.errors import ConnectionTimeoutError\n\ntry:\n    # Your code here\n    pass\nexcept ConnectionTimeoutError as e:\n    print(f\"ConnectionTimeoutError: {e}\")\n</code></pre>"},{"location":"#portinuseerror","title":"<code>PortInUseError</code>","text":"<p>Raised when a specified port is already in use.</p> <pre><code>from kn_sock.errors import PortInUseError\n\ntry:\n    # Your code here\n    pass\nexcept PortInUseError as e:\n    print(f\"PortInUseError: {e}\")\n</code></pre>"},{"location":"#data-protocol-errors","title":"Data &amp; Protocol Errors","text":""},{"location":"#invalidjsonerror","title":"<code>InvalidJSONError</code>","text":"<p>Raised when a JSON message cannot be decoded.</p> <pre><code>from kn_sock.errors import InvalidJSONError\n\ntry:\n    # Your code here\n    pass\nexcept InvalidJSONError as e:\n    print(f\"InvalidJSONError: {e}\")\n</code></pre>"},{"location":"#unsupportedprotocolerror","title":"<code>UnsupportedProtocolError</code>","text":"<p>Raised when a requested protocol is not supported.</p> <pre><code>from kn_sock.errors import UnsupportedProtocolError\n\ntry:\n    # Your code here\n    pass\nexcept UnsupportedProtocolError as e:\n    print(f\"UnsupportedProtocolError: {e}\")\n</code></pre>"},{"location":"#file-transfer-errors","title":"File Transfer Errors","text":""},{"location":"#filetransfererror","title":"<code>FileTransferError</code>","text":"<p>Raised when file transfer fails.</p> <pre><code>from kn_sock.errors import FileTransferError\n\ntry:\n    # Your code here\n    pass\nexcept FileTransferError as e:\n    print(f\"FileTransferError: {e}\")\n</code></pre>"},{"location":"#available-functions","title":"Available Functions","text":"<p>Note: All server functions (TCP, UDP, SSL, async/sync) accept a <code>shutdown_event</code> parameter for graceful shutdown. Use <code>threading.Event</code> for sync servers and <code>asyncio.Event</code> for async servers.</p>"},{"location":"#tcp-functions","title":"TCP Functions","text":"<ul> <li><code>start_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>start_threaded_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_tcp_message(host, port, message)</code></li> <li><code>send_tcp_bytes(host, port, data)</code></li> <li><code>start_async_tcp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_tcp_message_async(host, port, message)</code></li> <li><code>start_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_ssl_tcp_message(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code></li> <li><code>start_async_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_ssl_tcp_message_async(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code></li> </ul>"},{"location":"#udp-functions","title":"UDP Functions","text":"<ul> <li><code>start_udp_server(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_udp_message(host, port, message)</code></li> <li><code>start_udp_server_async(port, handler_func, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>send_udp_message_async(host, port, message)</code></li> <li><code>send_udp_multicast(group, port, message, ttl=1)</code></li> <li><code>start_udp_multicast_server(group, port, handler_func, listen_ip='0.0.0.0', shutdown_event=None)</code></li> </ul>"},{"location":"#file-transfer-functions","title":"File Transfer Functions","text":"<ul> <li><code>send_file(host, port, filepath)</code></li> <li><code>start_file_server(port, save_dir, host='0.0.0.0')</code></li> <li><code>send_file_async(host, port, filepath)</code></li> <li><code>start_file_server_async(port, save_dir, host='0.0.0.0')</code></li> </ul>"},{"location":"#json-functions","title":"JSON Functions","text":"<ul> <li><code>start_json_server(port, handler_func, host='0.0.0.0')</code></li> <li><code>send_json(host, port, obj, timeout=5)</code></li> <li><code>start_json_server_async(port, handler_func, host='0.0.0.0')</code></li> <li><code>send_json_async(host, port, obj)</code></li> <li><code>send_json_response(sock, data)</code></li> <li><code>send_json_response_async(writer, data)</code></li> </ul>"},{"location":"#websocket-functions","title":"WebSocket Functions","text":"<ul> <li><code>start_websocket_server(host, port, handler, shutdown_event=None)</code></li> <li><code>connect_websocket(host, port, resource='/', headers=None)</code></li> </ul>"},{"location":"#httphttps-functions","title":"HTTP/HTTPS Functions","text":"<ul> <li><code>http_get(host, port=80, path='/', headers=None)</code></li> <li><code>http_post(host, port=80, path='/', data='', headers=None)</code></li> <li><code>https_get(host, port=443, path='/', headers=None, cafile=None)</code></li> <li><code>https_post(host, port=443, path='/', data='', headers=None, cafile=None)</code></li> <li><code>start_http_server(host, port, static_dir=None, routes=None, shutdown_event=None)</code></li> </ul>"},{"location":"#pubsub-functions","title":"Pub/Sub Functions","text":"<ul> <li><code>start_pubsub_server(port, handler_func=None, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>PubSubClient(host, port)</code></li> </ul>"},{"location":"#rpc-functions","title":"RPC Functions","text":"<ul> <li><code>start_rpc_server(port, register_funcs, host='0.0.0.0', shutdown_event=None)</code></li> <li><code>RPCClient(host, port)</code></li> </ul>"},{"location":"#live-streaming-functions","title":"Live Streaming Functions","text":"<ul> <li><code>start_live_stream(port, video_paths, host='0.0.0.0', audio_port=None)</code></li> <li><code>connect_to_live_server(ip, port, audio_port=None)</code></li> </ul>"},{"location":"#multi-client-video-chat-with-voice","title":"Multi-Client Video Chat with Voice","text":"<p>The <code>kn_sock</code> library now supports real-time multi-client video chat with voice, allowing multiple users to join a room and communicate with both video and audio in real time.</p>"},{"location":"#features_2","title":"Features","text":"<ul> <li>Multi-client support: Multiple users can join the same room and see/hear each other.</li> <li>Rooms/Channels: Users can join named rooms; only users in the same room see/hear each other.</li> <li>User Nicknames: Each client can set a nickname, which is shared with the server and other clients.</li> <li>Text Chat: Real-time text messaging with chat overlay on video window.</li> <li>Mute/Unmute: Toggle audio on/off with keyboard shortcut.</li> <li>Video On/Off: Toggle video camera on/off with keyboard shortcut.</li> <li>Real-time video and audio: Uses OpenCV for video and PyAudio for audio.</li> <li>Simple API: Easy to start a server or connect as a client.</li> </ul>"},{"location":"#requirements_1","title":"Requirements","text":"<ul> <li>Python Dependencies: <code>opencv-python</code>, <code>pyaudio</code>, <code>numpy</code>, <code>pickle</code></li> <li>Hardware: Webcam and microphone for each client</li> <li>Network: TCP ports for video, audio, and text streams (default: 9000, 9001, and 9002)</li> </ul> <p>Note: Audio functionality requires proper PyAudio setup. If you encounter audio issues, you can disable audio and still use video and text chat features.</p>"},{"location":"#example-video-chat-server","title":"Example: Video Chat Server","text":"<pre><code>from kn_sock.video_chat import VideoChatServer\n\nserver = VideoChatServer(host='0.0.0.0', video_port=9000, audio_port=9001, text_port=9002)\nserver.start()\nprint('Video chat server started on ports 9000 (video), 9001 (audio), and 9002 (text).')\n\n# Keep the server running\ntry:\n    while True:\n        pass\nexcept KeyboardInterrupt:\n    print('Server stopped.')\n</code></pre>"},{"location":"#example-video-chat-client-with-room-and-nickname","title":"Example: Video Chat Client (with Room and Nickname)","text":"<pre><code>from kn_sock.video_chat import VideoChatClient\n\nclient = VideoChatClient(server_ip='127.0.0.1', video_port=9000, audio_port=9001, text_port=9002, room='myroom', nickname='alice')\nclient.start()\nprint('Connected to video chat server in room \"myroom\" as \"alice\".')\n\n# Keep the client running\ntry:\n    while client.running:\n        pass\nexcept KeyboardInterrupt:\n    print('Client stopped.')\n</code></pre>"},{"location":"#client-controls","title":"Client Controls","text":"<p>When the video window is active, you can use these keyboard shortcuts:</p> <ul> <li><code>m</code>: Mute/unmute your microphone</li> <li><code>v</code>: Toggle your video camera on/off</li> <li><code>q</code>: Quit the application</li> </ul>"},{"location":"#text-chat","title":"Text Chat","text":"<ul> <li>Type messages in the terminal and press Enter to send</li> <li>Chat messages appear as an overlay on the video window</li> <li>Messages include timestamps and sender nicknames</li> <li>Only users in the same room receive the messages</li> </ul>"},{"location":"#cli-example","title":"CLI Example","text":"<p>You can also use the provided example scripts:</p> <pre><code># Start the server\npython examples/video_chat_server.py\n\n# Start a client (in another terminal)\npython examples/video_chat_client.py &lt;server_ip&gt; &lt;room&gt; &lt;nickname&gt;\n</code></pre>"},{"location":"#cli-commands","title":"CLI Commands","text":"<p>The <code>kn-sock</code> CLI also supports video chat commands:</p> <pre><code># Start a video chat server\nkn-sock run-video-chat-server --host 0.0.0.0 --video-port 9000 --audio-port 9001 --text-port 9002\n\n# Connect to a video chat server\nkn-sock connect-video-chat &lt;server_ip&gt; &lt;room&gt; &lt;nickname&gt; --video-port 9000 --audio-port 9001 --text-port 9002\n</code></pre> <p>Note: Press 'q' in the video window or Ctrl+C in the terminal to stop the client.</p>"},{"location":"#troubleshooting","title":"Troubleshooting","text":"<p>If you encounter issues with video or audio, run the diagnostic tool first:</p> <pre><code>python examples/video_chat_diagnostic.py\n</code></pre>"},{"location":"#common-issues-and-solutions","title":"Common Issues and Solutions:","text":"<p>Audio Issues (Most Common): If you encounter PyAudio assertion errors or audio crashes, try these solutions:</p> <ol> <li> <p>Disable audio temporarily: <pre><code>python examples/video_chat_client.py 127.0.0.1 myroom alice --no-audio\n</code></pre></p> </li> <li> <p>Use the no-audio client: <pre><code>python examples/video_chat_client_no_audio.py 127.0.0.1 myroom alice\n</code></pre></p> </li> <li> <p>Test audio separately: <pre><code>python examples/test_audio_only.py\n</code></pre></p> </li> <li> <p>Install audio drivers (Arch Linux): <pre><code>sudo pacman -S pulseaudio pulseaudio-alsa\n</code></pre></p> </li> <li> <p>Set audio environment variables: <pre><code>export PULSE_SERVER=unix:/tmp/pulse-socket\nexport ALSA_PCM_CARD=0\n</code></pre></p> </li> </ol> <p>Display Issues: <pre><code># Set display backend for OpenCV\nexport QT_QPA_PLATFORM=xcb\n</code></pre></p> <p>Camera Issues: - Make sure your camera is not in use by another application - Check camera permissions - Try different camera device numbers if you have multiple cameras</p> <p>Dependencies: <pre><code># Install required packages\npip install opencv-python pyaudio numpy\n</code></pre></p> <p>Note: The video chat feature works perfectly without audio. If you have persistent audio issues, you can still use video and text chat functionality.</p>"},{"location":"#real-world-examples","title":"Real World Examples","text":"<p>Explore ready-to-run scripts that solve common networking problems using kn-sock:</p> <ul> <li>IoT Protocol: Custom JSON protocol for IoT devices</li> <li>File Transfer: Secure file transfer between machines</li> <li>Chat Application: Real-time chat using WebSockets</li> <li>Microservice RPC: Remote procedure calls between services</li> <li>Remote Control: Remote monitoring and control of applications</li> <li>HTTP API Server: Serve static files and simple APIs</li> <li>Live Streaming: Live video/audio streaming</li> <li>Test Utilities: Network test and utility scripts</li> </ul> <p>See the Real World Examples directory for all scripts and details.</p>"},{"location":"api/","title":"kn-sock API Reference","text":"<p>The kn-sock library offers a modern, Pythonic toolkit for socket programming, including TCP/UDP messaging, file transfer, live streaming, WebSockets, JSON sockets, pub/sub, and more.</p> <p>All features are available as both Python API functions and convenient CLI commands for rapid testing and automation.</p> <p>Quick Links: - TCP Utilities - UDP Utilities - HTTP/HTTPS Utilities - WebSocket Utilities - JSON Messaging - File Transfer - Live Streaming - Pub/Sub Messaging - RPC Utilities - Queues &amp; Threading - Configuration Utilities - Troubleshooting</p>"},{"location":"api/#key-features","title":"Key Features","text":"Feature Python API CLI Command(s) Purpose / Use Case TCP/UDP Messaging Yes Yes Network echo/test servers, quick data exchange File Transfer Yes Yes Move files between machines via TCP WebSocket Yes Yes Modern browser/client real-time comms HTTP/HTTPS Yes Yes Lightweight HTTP servers/clients Live Streaming Yes Yes Video/audio streaming across clients (FFmpeg/OpenCV) Pub/Sub Yes Yes Message broadcasting and topic subscriptions RPC Yes Yes Remote procedure call/test microservices JSON Sockets Yes Yes Send/receive structured data easily Interactive CLI \u2014 Yes Run all CLI features with guided prompts"},{"location":"api/#how-to-use","title":"How to Use","text":"<p>You can use kn-sock in two main ways:</p> <ol> <li> <p>From the command line:    Quickly spin up servers, clients, or file transfers with a single command.    See each protocol\u2019s page for sample commands.</p> </li> <li> <p>As a Python library:    Import and use the utilities in your own scripts or apps.    ```python    from kn_sock import start_tcp_server, send_tcp_message    # ... your code ...</p> </li> </ol>"},{"location":"api/api_reference/","title":"Python API Reference","text":""},{"location":"api/api_reference/#kn_sock.tcp.TCPConnectionPool","title":"<code>TCPConnectionPool</code>","text":"<p>Thread-safe TCP/SSL connection pool for efficient reuse of socket connections.</p> <p>Manages a pool of TCP or SSL connections to a given host and port, allowing multiple threads to acquire and release connections as needed. The pool automatically closes idle connections after a configurable timeout.</p> <p>Typical usage:</p> <pre><code>&gt;&gt;&gt; pool = TCPConnectionPool(\"localhost\", 8080, max_size=5, idle_timeout=30)\n&gt;&gt;&gt; with pool.connection() as conn:\n...     conn.sendall(b\"ping\")\n...     response = conn.recv(1024)\n&gt;&gt;&gt; pool.closeall()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>max_size</code> <code>int</code> <p>Maximum number of concurrent connections. Defaults to 5.</p> <code>5</code> <code>idle_timeout</code> <code>int</code> <p>Seconds before idle connections are closed. Defaults to 30.</p> <code>30</code> <code>ssl</code> <code>bool</code> <p>Whether to use SSL/TLS for connections. Defaults to False.</p> <code>False</code> <code>cafile</code> <code>str</code> <p>Path to CA certificate for SSL/TLS verification.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to client certificate for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to client private key for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Methods:</p> Name Description <code>connection</code> <p>Acquire a connection from the pool as a context manager.</p> <code>closeall</code> <p>Close all connections and clear the pool.</p> Notes <ul> <li>Connections are managed in a thread-safe manner using an internal lock.</li> <li>Idle connections are closed and removed from the pool after <code>idle_timeout</code> seconds.</li> <li>When <code>max_size</code> is reached, additional requests block until a connection is released.</li> </ul> Example <p>pool = TCPConnectionPool(\"localhost\", 8080, ssl=True, cafile=\"ca.pem\") with pool.connection() as conn: ...     conn.sendall(b\"hello\") ...     print(conn.recv(1024)) pool.closeall()</p>"},{"location":"api/api_reference/#kn_sock.tcp.start_tcp_server","title":"<code>start_tcp_server(port: int, handler_func: Callable[[bytes, tuple, socket.socket], None], host: str = '0.0.0.0', shutdown_event: Optional[threading.Event] = None)</code>","text":"<p>Starts a synchronous TCP server (IPv4/IPv6 supported).</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle (data, addr, client_socket).</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6).</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, server will exit when event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket fails.</p> <code>error</code> <p>For general network errors.</p> Example <p>def echo_handler(data, addr, sock): ...     print(data) ...     sock.sendall(data) start_tcp_server(8080, echo_handler)</p>"},{"location":"api/api_reference/#kn_sock.tcp.start_threaded_tcp_server","title":"<code>start_threaded_tcp_server(port: int, handler_func: Callable[[bytes, tuple, socket.socket], None], host: str = '0.0.0.0', shutdown_event: Optional[threading.Event] = None)</code>","text":"<p>Starts a multithreaded TCP server (IPv4/IPv6 supported).</p> <p>This function listens for incoming TCP connections on the specified port, spawning a new thread for each client. The handler function is called for each message received from a client.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle incoming data. Signature: (data: bytes, addr: tuple, client_socket: socket.socket) -&gt; None</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>error</code> <p>For network-related errors.</p> Example <p>def echo_handler(data, addr, sock): ...     print(f\"From {addr}: {data}\") ...     sock.sendall(b\"Echo: \" + data) import threading shutdown = threading.Event() start_threaded_tcp_server(8080, echo_handler, shutdown_event=shutdown)</p>"},{"location":"api/api_reference/#kn_sock.tcp.send_tcp_message","title":"<code>send_tcp_message(host: str, port: int, message: str)</code>","text":"<p>Sends a message to a TCP server (IPv4/IPv6 supported) and logs the server's response.</p> <p>Opens a TCP connection to the specified host and port, sends the given message as UTF-8 bytes, and logs the server's response (if any) to the logger. This function does not return the server's response.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_tcp_message(\"localhost\", 8080, \"hello world\")</p>"},{"location":"api/api_reference/#kn_sock.tcp.send_tcp_bytes","title":"<code>send_tcp_bytes(host: str, port: int, data: bytes)</code>","text":"<p>Sends raw bytes to a TCP server and logs the response.</p> <p>Opens a TCP connection to the specified host and port, sends the given data as-is (no encoding), and logs the server's response (if any) as bytes. This function does not return the response.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>data</code> <code>bytes</code> <p>The data to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_tcp_bytes(\"127.0.0.1\", 8080, b\"ping\")</p>"},{"location":"api/api_reference/#kn_sock.tcp.start_async_tcp_server","title":"<code>start_async_tcp_server(port: int, handler_func: Callable[[bytes, tuple, asyncio.StreamWriter], Awaitable[None]], host: str = '0.0.0.0', shutdown_event: Optional[asyncio.Event] = None)</code>  <code>async</code>","text":"<p>Starts an asynchronous TCP server (IPv4/IPv6 supported).</p> <p>Listens for incoming TCP connections on the specified port using asyncio, spawning a coroutine for each client. The handler function is called with received data, the client address, and the StreamWriter for responses. Supports graceful shutdown when a shutdown_event is set.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>Async function to handle incoming data. Signature: (data: bytes, addr: tuple, writer: asyncio.StreamWriter) -&gt; Awaitable[None]</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>CancelledError</code> <p>If the server task is cancelled.</p> Example <p>import asyncio async def echo_handler(data, addr, writer): ...     print(f\"Received from {addr}: {data.decode()}\") ...     writer.write(b\"Echo: \" + data) ...     await writer.drain() asyncio.run(start_async_tcp_server(8080, echo_handler))</p>"},{"location":"api/api_reference/#kn_sock.tcp.send_tcp_message_async","title":"<code>send_tcp_message_async(host: str, port: int, message: str)</code>  <code>async</code>","text":"<p>Sends a message to a TCP server asynchronously and returns the response.</p> <p>Opens an asynchronous TCP connection to the specified host and port, sends the given message as UTF-8 bytes, and awaits the server's response as a string. Returns None if no response is received.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>import asyncio response = asyncio.run(send_tcp_message_async(\"localhost\", 8080, \"hello async\")) print(response) Echo: hello async</p>"},{"location":"api/api_reference/#kn_sock.tcp.start_ssl_tcp_server","title":"<code>start_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event: Optional[threading.Event] = None)</code>","text":"<p>Starts a synchronous SSL/TLS TCP server with optional client certificate verification.</p> <p>Listens for incoming SSL/TLS connections on the specified port. For each client connection, wraps the socket with SSL/TLS, then invokes the handler function with the received data, client address, and SSL socket. Supports IPv4 and IPv6.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle incoming data. Signature: (data: bytes, addr: tuple, ssl_sock: ssl.SSLSocket) -&gt; None</p> required <code>certfile</code> <code>str</code> <p>Path to the server certificate file in PEM format.</p> required <code>keyfile</code> <code>str</code> <p>Path to the server private key file in PEM format.</p> required <code>cafile</code> <code>str</code> <p>Path to CA certificate for verifying client certificates.</p> <code>None</code> <code>require_client_cert</code> <code>bool</code> <p>Whether to require client certificates for mutual TLS. Defaults to False.</p> <code>False</code> <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>SSLError</code> <p>For SSL/TLS handshake or certificate errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>def echo_handler(data, addr, ssl_sock): ...     print(f\"Received from {addr}: {data}\") ...     ssl_sock.sendall(b\"Echo: \" + data) start_ssl_tcp_server( ...     port=8443, ...     handler_func=echo_handler, ...     certfile=\"server.pem\", ...     keyfile=\"server-key.pem\" ... )</p>"},{"location":"api/api_reference/#kn_sock.tcp.send_ssl_tcp_message","title":"<code>send_ssl_tcp_message(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code>","text":"<p>Sends a message to an SSL/TLS TCP server and returns the response.</p> <p>Opens a secure SSL/TLS connection to the specified host and port, sends the given message as UTF-8 bytes, and returns the server's response as a string if one is received. Supports server verification and mutual TLS.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <code>cafile</code> <code>str</code> <p>Path to a CA certificate file for verifying the server.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to the client certificate file for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to the client private key file for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>SSLError</code> <p>For SSL/TLS handshake or verification errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_ssl_tcp_message( ...     host=\"localhost\", ...     port=8443, ...     message=\"secure hello\", ...     cafile=\"ca.pem\" ... ) 'Echo: secure hello'</p>"},{"location":"api/api_reference/#kn_sock.tcp.start_async_ssl_tcp_server","title":"<code>start_async_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event: Optional[asyncio.Event] = None)</code>  <code>async</code>","text":"<p>Starts an asynchronous SSL/TLS TCP server with optional client certificate verification.</p> <p>Listens for incoming SSL/TLS connections using asyncio on the specified port. For each client, wraps the connection with SSL/TLS and invokes the provided async handler function with the received data, client address, and StreamWriter. Supports IPv4 and IPv6, as well as graceful shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>Async function to handle incoming data. Signature: (data: bytes, addr: tuple, writer: asyncio.StreamWriter) -&gt; Awaitable[None]</p> required <code>certfile</code> <code>str</code> <p>Path to the server certificate file in PEM format.</p> required <code>keyfile</code> <code>str</code> <p>Path to the server private key file in PEM format.</p> required <code>cafile</code> <code>str</code> <p>Path to CA certificate for verifying client certificates.</p> <code>None</code> <code>require_client_cert</code> <code>bool</code> <p>Whether to require client certificates for mutual TLS. Defaults to False.</p> <code>False</code> <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>SSLError</code> <p>For SSL/TLS handshake or certificate errors.</p> <code>CancelledError</code> <p>If the server task is cancelled.</p> Example <p>import asyncio async def echo_handler(data, addr, writer): ...     print(f\"Received from {addr}: {data.decode()}\") ...     writer.write(b\"Echo: \" + data) ...     await writer.drain() asyncio.run(start_async_ssl_tcp_server( ...     port=8443, ...     handler_func=echo_handler, ...     certfile=\"server.pem\", ...     keyfile=\"server-key.pem\" ... ))</p>"},{"location":"api/api_reference/#kn_sock.tcp.send_ssl_tcp_message_async","title":"<code>send_ssl_tcp_message_async(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code>  <code>async</code>","text":"<p>Sends a message to an SSL/TLS TCP server asynchronously and returns the response.</p> <p>Opens an asynchronous SSL/TLS connection to the specified host and port, sends the given message as UTF-8 bytes, and awaits the server's response as a string. Supports server verification and mutual TLS authentication.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <code>cafile</code> <code>str</code> <p>Path to a CA certificate file for verifying the server.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to the client certificate file for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to the client private key file for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>SSLError</code> <p>For SSL/TLS handshake or verification errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>import asyncio response = asyncio.run( ...     send_ssl_tcp_message_async( ...         host=\"localhost\", ...         port=8443, ...         message=\"secure async hello\", ...         cafile=\"ca.pem\" ...     ) ... ) print(response) Echo: secure async hello</p>"},{"location":"api/api_reference/#kn_sock.udp.start_udp_server","title":"<code>start_udp_server(port: int, handler_func: Callable[[bytes, tuple, socket.socket], None], host: str = '0.0.0.0', shutdown_event=None)</code>","text":"<p>Starts a synchronous UDP server that listens for incoming datagrams and delegates them to a handler function.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>A function that handles incoming data.  Called as <code>handler_func(data, addr, socket)</code>.</p> required <code>host</code> <code>str</code> <p>Host/IP to bind to. Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will shut down gracefully when the event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the socket fails to bind or encounters an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def echo_handler(data, addr, sock):\n...     print(f\"Received from {addr}: {data.decode()}\")\n...     sock.sendto(data, addr)\n&gt;&gt;&gt; import threading\n&gt;&gt;&gt; stop_event = threading.Event()\n&gt;&gt;&gt; start_udp_server(8081, echo_handler, shutdown_event=stop_event)\n</code></pre>"},{"location":"api/api_reference/#kn_sock.udp.send_udp_message","title":"<code>send_udp_message(host: str, port: int, message: str)</code>","text":"<p>Sends a UTF-8 encoded message to a UDP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Target server hostname or IP address.</p> required <code>port</code> <code>int</code> <p>Destination port on the server.</p> required <code>message</code> <code>str</code> <p>Message to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If sending the datagram fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; send_udp_message(\"127.0.0.1\", 8081, \"Hello UDP\")\n</code></pre>"},{"location":"api/api_reference/#kn_sock.udp.start_udp_server_async","title":"<code>start_udp_server_async(port: int, handler_func: Callable[[bytes, tuple, asyncio.DatagramTransport], Awaitable[None]], host: str = '0.0.0.0', shutdown_event=None)</code>  <code>async</code>","text":"<p>Starts an asynchronous UDP server using asyncio. Runs a handler for each incoming datagram.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>Async function called as <code>await handler_func(data, addr, transport)</code>.</p> required <code>host</code> <code>str</code> <p>Host/IP to bind to. Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit when the event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If socket setup fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; async def echo_handler(data, addr, transport):\n...     print(f\"Received from {addr}: {data.decode()}\")\n...     transport.sendto(data, addr)\n&gt;&gt;&gt; asyncio.run(start_udp_server_async(8082, echo_handler))\n</code></pre>"},{"location":"api/api_reference/#kn_sock.udp.send_udp_message_async","title":"<code>send_udp_message_async(host: str, port: int, message: str)</code>  <code>async</code>","text":"<p>Sends a UTF-8 message asynchronously to a UDP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Target server hostname or IP address.</p> required <code>port</code> <code>int</code> <p>Destination port on the server.</p> required <code>message</code> <code>str</code> <p>Message to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If sending the message fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; asyncio.run(send_udp_message_async(\"127.0.0.1\", 8082, \"Async Hello\"))\n</code></pre>"},{"location":"api/api_reference/#kn_sock.udp.send_udp_multicast","title":"<code>send_udp_multicast(group: str, port: int, message: str, ttl: int = 1)</code>","text":"<p>Sends a multicast UDP message to a given group and port.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Multicast group IP (e.g., '224.0.0.1').</p> required <code>port</code> <code>int</code> <p>Multicast port number.</p> required <code>message</code> <code>str</code> <p>Message to send.</p> required <code>ttl</code> <code>int</code> <p>Time-to-live for multicast packets. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If socket configuration or send fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; send_udp_multicast(\"224.0.0.1\", 9000, \"Multicast Hello\")\n</code></pre>"},{"location":"api/api_reference/#kn_sock.udp.start_udp_multicast_server","title":"<code>start_udp_multicast_server(group: str, port: int, handler_func: Callable[[bytes, tuple, socket.socket], None], listen_ip: str = '0.0.0.0', shutdown_event=None)</code>","text":"<p>Starts a UDP multicast server that listens for messages on a specified group and port.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Multicast group IP (e.g., '224.0.0.1').</p> required <code>port</code> <code>int</code> <p>Multicast port to listen on.</p> required <code>handler_func</code> <code>Callable</code> <p>Function called as <code>handler_func(data, addr, socket)</code> for each received message.</p> required <code>listen_ip</code> <code>str</code> <p>Local interface IP to bind to. Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will shut down when the event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If socket configuration or binding fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def handler(data, addr, sock):\n...     print(f\"[MULTICAST] Received from {addr}: {data.decode()}\")\n&gt;&gt;&gt; import threading\n&gt;&gt;&gt; stop_event = threading.Event()\n&gt;&gt;&gt; start_udp_multicast_server(\"224.0.0.1\", 9000, handler, shutdown_event=stop_event)\n</code></pre>"},{"location":"api/config/","title":"Configuration &amp; Environment Variables","text":"<p>kn-sock can be configured using CLI arguments, environment variables, or direct Python parameters.  </p> <p>This page summarizes supported options and recommended practices for customizing runtime behavior.</p>"},{"location":"api/config/#cli-configuration","title":"CLI Configuration","text":"<p>Most CLI commands support options like <code>--host</code>, <code>--port</code>, or protocol-specific flags. Check <code>--help</code> on any command for available options.</p> <p>Example: <pre><code>docker-compose run --rm knsock run-tcp-server 9000 --host 0.0.0.0\n</code></pre></p>"},{"location":"api/config/#options-table","title":"Options Table","text":"Option Description <code>--host</code> Host/IP address (if supported) <code>--port</code> Port number (if supported) Environment vars e.g., <code>KNSOCK_LOGLEVEL=DEBUG</code>"},{"location":"api/config/#environment-variables","title":"Environment Variables","text":"<p>Set environment variables to adjust logging, debugging, and other behavior globally.</p> Variable Description Example Value KNSOCK_LOGLEVEL Python logging level DEBUG, INFO KNSOCK_CONFIG Path to a config file (if supported) ./knsock.cfg PYTHONUNBUFFERED Unbuffered output for Docker logs 1 <p>Set in shell: <pre><code>export KNSOCK_LOGLEVEL=DEBUG\ndocker-compose run --rm knsock run-tcp-server 9000\n</code></pre></p> <p>Or in Docker Compose: <pre><code>services:\n  knsock:\n    environment:\n      - KNSOCK_LOGLEVEL=DEBUG\n</code></pre></p>"},{"location":"api/config/#python-api-configuration","title":"Python API Configuration","text":"<p>Most kn-sock server/client functions accept keyword arguments for customization.</p> <p>Example: <pre><code>from kn_sock import start_tcp_server\n\nstart_tcp_server(9000, host='0.0.0.0', loglevel='DEBUG')\n</code></pre></p>"},{"location":"api/config/#sample-config-file-custom-usage","title":"Sample Config File (Custom Usage)","text":"<p>If your project extends kn-sock, you may use config files in INI, YAML, or JSON format. Example (knsock.cfg): <pre><code>[server]\nhost = 0.0.0.0\nport = 9000\nloglevel = INFO\n</code></pre></p> <p>Read this file in your own Python wrapper or extend kn-sock\u2019s startup code.</p>"},{"location":"api/config/#best-practices","title":"Best Practices","text":"<p>Prefer CLI flags for per-invocation overrides.</p> <p>Use environment variables for cross-platform, repeatable setups (especially in Docker).</p> <p>For complex deployments, use configuration files and parse them at the application level.</p>"},{"location":"api/config/#troubleshooting","title":"Troubleshooting","text":"Issue Symptom/Output Solution Logging not verbose No debug output in terminal Set KNSOCK_LOGLEVEL=DEBUG Config not applied No change despite editing config Confirm correct syntax and load sequence Docker not picking up env No effect in container Use environment: in Compose, not just export"},{"location":"api/file_transfer/","title":"File Transfer Utilities","text":"<p>kn-sock includes utilities for sending and receiving files over TCP\u2014ideal for quick one-off transfers, automation, or as a building block for larger workflows.</p>"},{"location":"api/file_transfer/#cli-commands","title":"CLI Commands","text":""},{"location":"api/file_transfer/#1-start-a-file-receiver-server","title":"1. Start a File Receiver Server","text":"<p>Launch a TCP server that receives and saves incoming files to a specified directory.</p> Command Description <code>run-file-server &lt;port&gt; &lt;save_dir&gt;</code> Start a TCP file receiver <p>Example: <pre><code>docker-compose run --rm knsock run-file-server 7001 /tmp/incoming\n# Or: knsock run-file-server 7001 /tmp/incoming\n</code></pre> Output: <pre><code>[FILE][SERVER] Listening on 0.0.0.0:7001\n[FILE][SERVER] Saving received files to /tmp/incoming\n</code></pre></p>"},{"location":"api/file_transfer/#2-send-a-file","title":"2. Send a File","text":"<p>Send a file to a TCP file receiver server.</p> Command Description <code>send-file &lt;host&gt; &lt;port&gt; &lt;filepath&gt;</code> Send a file over TCP <p>Example: <pre><code>docker-compose run --rm knsock send-file 172.18.0.2 7001 ./README.md\n</code></pre> Output: <pre><code>[FILE][CLIENT] Sent file: ./README.md to 172.18.0.2:7001\n</code></pre></p>"},{"location":"api/file_transfer/#options-table","title":"Options Table","text":"Option Description <code>&lt;port&gt;</code> Port number for server/client <code>&lt;host&gt;</code> IP or hostname of server (for client) <code>&lt;filepath&gt;</code> Path to file to send (client) <code>&lt;save_dir&gt;</code> Directory to save received files (server)"},{"location":"api/file_transfer/#python-api","title":"Python API","text":""},{"location":"api/file_transfer/#start-a-file-server","title":"Start a File Server","text":"<pre><code>from kn_sock import start_file_server\n\nstart_file_server(7001, save_dir=\"/tmp/incoming\")\n</code></pre>"},{"location":"api/file_transfer/#send-a-file","title":"Send a File","text":"<pre><code>from kn_sock import send_file\n\nsend_file(\"127.0.0.1\", 7001, \"./README.md\")\n</code></pre>"},{"location":"api/file_transfer/#sample-output","title":"Sample Output","text":"<p>Server terminal: <pre><code>[FILE][SERVER] Listening on 0.0.0.0:7001\n[FILE][SERVER] Saving received files to /tmp/incoming\n[FILE][SERVER] Received file: README.md from ('172.18.0.1', 59923)\n</code></pre></p> <p>Client terminal: <pre><code>[FILE][CLIENT] Sent file: ./README.md to 172.18.0.2:7001\n</code></pre></p>"},{"location":"api/file_transfer/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution File not saved No file appears in save_dir Check write permissions on server directory File too large / incomplete Partial file or error Check network stability and disk space Port already in use <code>[Errno 98] Address in use</code> Use a different port or stop other processes Hostname not found <code>[Errno -2] Name or service not known</code> Use container IP in Docker setups"},{"location":"api/file_transfer/#testing","title":"Testing","text":""},{"location":"api/file_transfer/#manual-test","title":"Manual Test","text":"<p>Start the file server: <pre><code>docker-compose run --rm knsock run-file-server 7001 /tmp/incoming\n</code></pre></p> <p>In another terminal, send a file: <pre><code>docker-compose run --rm knsock send-file &lt;server-ip&gt; 7001 ./README.md\n# Example: send-file 172.18.0.2 7001 ./README.md\n</code></pre></p> <p>Check <code>/tmp/incoming</code> in the container for the transferred file.</p>"},{"location":"api/json/","title":"JSON Messaging Utilities","text":"<p>kn-sock supports sending and receiving structured JSON data over sockets, making it easy to build APIs, automation tools, and structured communication between systems.</p>"},{"location":"api/json/#cli-commands","title":"CLI Commands","text":""},{"location":"api/json/#1-json-over-tcpudp","title":"1. JSON over TCP/UDP","text":"<p>While there are no dedicated <code>send-json</code> or <code>run-json-server</code> CLI commands, you can send JSON strings as messages using the standard TCP/UDP commands. JSON socket helpers in the Python API handle encoding/decoding for you.</p> <p>Example: <pre><code>docker-compose run --rm knsock send-tcp 172.18.0.2 8080 '{\"type\": \"ping\", \"payload\": 123}'\n</code></pre></p>"},{"location":"api/json/#python-api","title":"Python API","text":""},{"location":"api/json/#send-and-receive-json-messages-tcp-example","title":"Send and Receive JSON Messages (TCP Example)","text":"<pre><code>from kn_sock.json_socket import send_json, start_json_server\n\ndef handle_json(data, addr, conn):\n    print(f\"Received JSON: {data}\")\n    conn.sendall({\"type\": \"pong\", \"payload\": 456})\n\n# Start a TCP JSON echo server on port 7000\nstart_json_server(7000, handle_json)\n</code></pre>"},{"location":"api/json/#send-a-json-message-client","title":"Send a JSON message (client):","text":"<pre><code>from kn_sock.json_socket import send_json\n\nresponse = send_json(\"127.0.0.1\", 7000, {\"type\": \"ping\", \"payload\": 123})\nprint(response)\n</code></pre>"},{"location":"api/json/#options-table","title":"Options Table","text":"Option Description <code>&lt;host&gt;</code> Server IP or hostname <code>&lt;port&gt;</code> Port number <code>&lt;json&gt;</code> JSON string or dict to send"},{"location":"api/json/#sample-output","title":"Sample Output","text":"<p>Server terminal: <pre><code>[JSON][SERVER] Received from ('172.18.0.1', 56601): {'type': 'ping', 'payload': 123}\n</code></pre></p> <p>Client terminal: <pre><code>[JSON][CLIENT] Sent: {'type': 'ping', 'payload': 123}\n[JSON][CLIENT] Received: {'type': 'pong', 'payload': 456}\n</code></pre></p>"},{"location":"api/json/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution Invalid JSON Exception or parse error Validate JSON syntax before sending No response Hangs or empty result Check server is running and handles JSON Encoding errors Unicode/byte issues Always use UTF-8 and send as string or bytes Docker: hostname error <code>[Errno -2] Name or service not known</code> Use container IP, not name, in Docker setups"},{"location":"api/json/#testing","title":"Testing","text":""},{"location":"api/json/#manual-test","title":"Manual Test","text":"<p>Start a JSON server in Python: <pre><code>from kn_sock.json_socket import start_json_server\n\ndef handle_json(data, addr, conn):\n    print(\"Received:\", data)\n    conn.sendall({\"ok\": True})\n\nstart_json_server(7000, handle_json)\n</code></pre></p> <p>Send a JSON message (in another terminal or script): <pre><code>from kn_sock.json_socket import send_json\nprint(send_json(\"127.0.0.1\", 7000, {\"test\": 1}))\n</code></pre></p> <p>Or use CLI to send a raw JSON string: <pre><code>docker-compose run --rm knsock send-tcp &lt;server-ip&gt; 7000 '{\"test\": 1}'\n</code></pre></p>"},{"location":"api/live_stream/","title":"Live Streaming Utilities","text":"<p>kn-sock supports real-time video and audio streaming over the network, using FFmpeg and OpenCV.  </p> <p>Use these tools for demos, surveillance, or experimental real-time media pipelines.</p>"},{"location":"api/live_stream/#cli-commands","title":"CLI Commands","text":""},{"location":"api/live_stream/#1-start-a-live-videoaudio-stream-server","title":"1. Start a Live Video/Audio Stream Server","text":"<p>Stream one or more video files (with audio) to connected clients.</p> Command Description <code>run-live-server &lt;port&gt; &lt;video_paths...&gt; [--host &lt;host&gt;] [--audio-port &lt;audio_port&gt;]</code> Start live streaming server <p>Example: <pre><code>docker-compose run --rm knsock run-live-server 9002 demo.mp4\n# Or to specify host/audio port:\ndocker-compose run --rm knsock run-live-server 9002 demo.mp4 --host 0.0.0.0 --audio-port 9003\n</code></pre> Output: <pre><code>[LIVE][SERVER] Streaming video(s): demo.mp4 on 0.0.0.0:9002, audio on 0.0.0.0:9003\n</code></pre></p>"},{"location":"api/live_stream/#2-connect-to-a-live-videoaudio-stream","title":"2. Connect to a Live Video/Audio Stream","text":"<p>Connect as a client to the live stream server and display the stream.</p> Command Description <code>connect-live-server &lt;ip&gt; &lt;video_port&gt; [--audio-port &lt;audio_port&gt;]</code> Connect and view stream <p>Example: <pre><code>docker-compose run --rm knsock connect-live-server 172.18.0.2 9002\n# Specify audio port if needed:\ndocker-compose run --rm knsock connect-live-server 172.18.0.2 9002 --audio-port 9003\n</code></pre> Output: <pre><code>[LIVE][CLIENT] Connecting to video at 172.18.0.2:9002 (audio: 9003)\n[LIVE][CLIENT] Displaying video stream...\n</code></pre></p>"},{"location":"api/live_stream/#options-table","title":"Options Table","text":"Option Description <code>&lt;port&gt;</code> Video port for server/client <code>&lt;video_paths&gt;</code> One or more video file paths to stream (server) <code>&lt;host&gt;</code> Host to bind (default: 0.0.0.0; server only) <code>&lt;audio_port&gt;</code> Audio port (default: +1) <code>&lt;ip&gt;</code> Server IP address (client only)"},{"location":"api/live_stream/#python-api","title":"Python API","text":""},{"location":"api/live_stream/#start-a-live-stream-server","title":"Start a Live Stream Server","text":"<pre><code>from kn_sock import start_live_stream\n\n# Stream video and audio from local files on port 9002 (video), 9003 (audio)\nstart_live_stream(9002, [\"demo.mp4\"])\n</code></pre>"},{"location":"api/live_stream/#connect-as-a-stream-client","title":"Connect as a Stream Client","text":"<pre><code>from kn_sock import connect_to_live_server\n\nconnect_to_live_server(\"127.0.0.1\", 9002)  # (video port, default audio port is 9003)\n</code></pre>"},{"location":"api/live_stream/#sample-output","title":"Sample Output","text":"<p>Server terminal: <pre><code>[LIVE][SERVER] Streaming video(s): demo.mp4 on 0.0.0.0:9002, audio on 0.0.0.0:9003\n[LIVE][SERVER] Waiting for clients...\n</code></pre></p> <p>Client terminal: <pre><code>[LIVE][CLIENT] Connecting to video at 172.18.0.2:9002 (audio: 9003)\n[LIVE][CLIENT] Displaying video stream...\n</code></pre></p>"},{"location":"api/live_stream/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution Missing dependencies <code>ImportError: libGL.so.1...</code> Install OpenCV and required system libraries Video not displayed No window appears, blank screen Check local GUI/X11 settings in container Connection refused <code>ConnectionRefusedError</code> Ensure server is running, ports are open Audio issues No sound, audio errors Confirm audio port and codec compatibility"},{"location":"api/live_stream/#testing","title":"Testing","text":""},{"location":"api/live_stream/#manual-test","title":"Manual Test","text":"<p>Start the server (with a sample video in the container): <pre><code>docker-compose run --rm knsock run-live-server 9002 demo.mp4\n</code></pre></p> <p>In another terminal, connect as a client: <pre><code>docker-compose run --rm knsock connect-live-server &lt;server-ip&gt; 9002\n# Example: connect-live-server 172.18.0.2 9002\n</code></pre></p> <p>Observe video window/audio output on the client side.</p> <p>Note: Live video streaming may require proper video files and local display access in Docker environments. Test outside Docker if GUI support is limited.</p>"},{"location":"api/pubsub/","title":"Pub/Sub Messaging Utilities","text":"<p>kn-sock offers simple publish/subscribe (pub/sub) messaging for distributed notification and event-driven testing.</p> <p>Use pub/sub for broadcasting updates, fan-out, or basic topic-based communication.</p>"},{"location":"api/pubsub/#cli-commands","title":"CLI Commands","text":""},{"location":"api/pubsub/#1-start-a-pubsub-server","title":"1. Start a Pub/Sub Server","text":"<p>Launch a pub/sub server that handles topic subscriptions and message publishing.</p> Command Description <code>run-pubsub-server &lt;port&gt;</code> Start a pub/sub messaging server <p>Example: <pre><code>docker-compose run --rm knsock run-pubsub-server 9100\n# Or: knsock run-pubsub-server 9100\n</code></pre> Output: <pre><code>[PUBSUB][SERVER] Listening on 0.0.0.0:9100\n</code></pre></p>"},{"location":"api/pubsub/#2-connect-as-a-pubsub-client","title":"2. Connect as a Pub/Sub Client","text":"<p>Subscribe to a topic, publish messages, and receive updates.</p> Command Description <code>pubsub-client &lt;host&gt; &lt;port&gt;</code> Connect as pub/sub client <p>Example: <pre><code>docker-compose run --rm knsock pubsub-client 172.18.0.2 9100\n</code></pre> Interactive client: enter commands in the terminal, e.g.: <pre><code>subscribe test\npublish test Hello, PubSub!\n# Output: Received on [test]: Hello, PubSub!\n</code></pre></p>"},{"location":"api/pubsub/#options-table","title":"Options Table","text":"Option Description <code>&lt;port&gt;</code> Port for server/client <code>&lt;host&gt;</code> IP/hostname of server (client only)"},{"location":"api/pubsub/#python-api","title":"Python API","text":""},{"location":"api/pubsub/#start-a-pubsub-server","title":"Start a Pub/Sub Server","text":"<pre><code>from kn_sock import start_pubsub_server\n\nstart_pubsub_server(9100)\n</code></pre>"},{"location":"api/pubsub/#connect-as-a-pubsub-client","title":"Connect as a Pub/Sub Client","text":"<pre><code>from kn_sock import PubSubClient\n\nclient = PubSubClient('127.0.0.1', 9100)\nclient.subscribe('test')\nclient.publish('test', 'Hello, PubSub!')\n# Listen for messages...\n</code></pre>"},{"location":"api/pubsub/#sample-output","title":"Sample Output","text":"<p>Server terminal: <pre><code>[PUBSUB][SERVER] Listening on 0.0.0.0:9100\n[PUBSUB][SERVER] Client subscribed to: test\n[PUBSUB][SERVER] Message published to [test]: Hello, PubSub!\n</code></pre></p> <p>Client terminal: <pre><code>[PUBSUB][CLIENT] Subscribed to topic: test\n[PUBSUB][CLIENT] Published to topic [test]: Hello, PubSub!\n[PUBSUB][CLIENT] Received on [test]: Hello, PubSub!\n</code></pre></p>"},{"location":"api/pubsub/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution No messages received No output after subscribe Make sure at least one message published Connection refused <code>ConnectionRefusedError</code> Ensure server is running Hostname not found <code>[Errno -2] Name or service not known</code> Use container IP in Docker"},{"location":"api/pubsub/#testing","title":"Testing","text":""},{"location":"api/pubsub/#manual-test","title":"Manual Test","text":"<p>Start the pub/sub server: <pre><code>docker-compose run --rm knsock run-pubsub-server 9100\n</code></pre></p> <p>In another terminal, connect as a client: <pre><code>docker-compose run --rm knsock pubsub-client &lt;server-ip&gt; 9100\n# Example: pubsub-client 172.18.0.2 9100\n</code></pre></p> <p>In the client, type: <pre><code>subscribe test\npublish test Hello, PubSub!\n</code></pre></p> <p>You should see the published message received in the client output.</p>"},{"location":"api/queue/","title":"Queue Utilities","text":"<p>kn-sock includes basic queue utilities and configuration helpers\u2014useful for message buffering, distributed jobs, and customizing runtime behavior.</p>"},{"location":"api/queue/#cli-commands","title":"CLI Commands","text":"<p>No dedicated CLI commands for queues or config. Use Python API as shown below.</p>"},{"location":"api/queue/#python-api","title":"Python API","text":""},{"location":"api/queue/#in-memory-queue-example","title":"In-Memory Queue Example","text":"<p>Use the built-in <code>Queue</code> for simple producer/consumer patterns.</p> <pre><code>from kn_sock.queue import Queue\n\nq = Queue()\nq.put(\"job1\")\nq.put(\"job2\")\n\nwhile not q.empty():\n    print(q.get())\n# Output:\n# job1\n# job2\n</code></pre>"},{"location":"api/queue/#configuration-example","title":"Configuration Example","text":"<p>Configuration options can be set using environment variables or passed directly to API calls. Most CLI commands also accept <code>--host</code>, <code>--port</code>, or other options for customization.</p>"},{"location":"api/queue/#sample-output","title":"Sample Output","text":"<pre><code>job1\njob2\n</code></pre>"},{"location":"api/queue/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution Queue deadlock Script hangs Use timeouts or check <code>empty()</code> before <code>get()</code> Invalid config Errors at runtime Check supported options in the docs"},{"location":"api/queue/#testing","title":"Testing","text":""},{"location":"api/queue/#manual-test","title":"Manual Test","text":"<p>Create a Python script: <pre><code>from kn_sock.queue import Queue\nq = Queue()\nq.put(\"test1\")\nq.put(\"test2\")\nwhile not q.empty():\n    print(q.get())\n</code></pre></p> <p>Run the script. You should see both items printed.</p>"},{"location":"api/rpc/","title":"RPC Utilities","text":"<p>kn-sock includes simple remote procedure call (RPC) utilities to demonstrate calling functions on remote servers for use in basic microservices, distributed testing, or automation.</p>"},{"location":"api/rpc/#cli-commands","title":"CLI Commands","text":""},{"location":"api/rpc/#1-start-an-rpc-server","title":"1. Start an RPC Server","text":"<p>Run a server that exposes simple functions (e.g., add, echo) to remote clients.</p> Command Description <code>run-rpc-server &lt;port&gt;</code> Start an RPC server <p>Example: <pre><code>docker-compose run --rm knsock run-rpc-server 9200\n# Or: knsock run-rpc-server 9200\n</code></pre> Output: <pre><code>[RPC][SERVER] Listening on 0.0.0.0:9200\n</code></pre></p>"},{"location":"api/rpc/#2-connect-as-an-rpc-client","title":"2. Connect as an RPC Client","text":"<p>Invoke a remote function exposed by the server (e.g., add, echo).</p> Command Description <code>rpc-client &lt;host&gt; &lt;port&gt; &lt;function&gt; [args...]</code> Call remote function via RPC <p>Example: <pre><code>docker-compose run --rm knsock rpc-client 172.18.0.2 9200 add 2 3\n</code></pre> Output: <pre><code>[RPC][CLIENT] add(2, 3) \u2192 5\n</code></pre></p> <p>Or, to echo a string: <pre><code>docker-compose run --rm knsock rpc-client 172.18.0.2 9200 echo \"hello\"\n</code></pre> Output: <pre><code>[RPC][CLIENT] echo('hello') \u2192 'hello'\n</code></pre></p>"},{"location":"api/rpc/#options-table","title":"Options Table","text":"Option Description <code>&lt;port&gt;</code> Port for server/client <code>&lt;host&gt;</code> IP/hostname of server (client only) <code>&lt;function&gt;</code> Function to call (e.g., add, echo) <code>[args...]</code> Arguments for the remote function (space-separated)"},{"location":"api/rpc/#python-api","title":"Python API","text":""},{"location":"api/rpc/#start-an-rpc-server","title":"Start an RPC Server","text":"<pre><code>from kn_sock import start_rpc_server\n\nstart_rpc_server(9200)\n</code></pre>"},{"location":"api/rpc/#call-as-an-rpc-client","title":"Call as an RPC Client","text":"<pre><code>from kn_sock import RPCClient\n\nclient = RPCClient('127.0.0.1', 9200)\nprint(client.call('add', 2, 3))  # \u2192 5\nprint(client.call('echo', 'hello'))  # \u2192 'hello'\n</code></pre>"},{"location":"api/rpc/#sample-output","title":"Sample Output","text":"<p>Server terminal: <pre><code>[RPC][SERVER] Listening on 0.0.0.0:9200\n[RPC][SERVER] Received call: add(2, 3) from ('172.18.0.1', 60222)\n</code></pre></p> <p>Client terminal: <pre><code>[RPC][CLIENT] add(2, 3) \u2192 5\n[RPC][CLIENT] echo('hello') \u2192 'hello'\n</code></pre></p>"},{"location":"api/rpc/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution Function not found Error: function not implemented Use only supported functions (add, echo) Connection refused <code>ConnectionRefusedError</code> Ensure server is running Hostname not found <code>[Errno -2] Name or service not known</code> Use container IP for Docker setups"},{"location":"api/rpc/#testing","title":"Testing","text":""},{"location":"api/rpc/#manual-test","title":"Manual Test","text":"<p>Start the RPC server: <pre><code>docker-compose run --rm knsock run-rpc-server 9200\n</code></pre></p> <p>In another terminal, call a function: <pre><code>docker-compose run --rm knsock rpc-client &lt;server-ip&gt; 9200 add 2 3\n# Example: rpc-client 172.18.0.2 9200 add 2 3\n</code></pre></p> <p>Try another function: <pre><code>docker-compose run --rm knsock rpc-client &lt;server-ip&gt; 9200 echo \"test\"\n</code></pre></p> <p>You should see results printed for each call.</p>"},{"location":"api/tcp_test/","title":"Tabs Demo","text":""},{"location":"api/tcp_test/#basic-tabs","title":"Basic Tabs","text":"PythonJavaScriptShell <pre><code>def greet():\n    print(\"Hello from Python!\")\n</code></pre> <pre><code>function greet() {\n    console.log(\"Hello from JavaScript!\");\n}\n</code></pre> <pre><code>echo \"Hello from Bash\"\n</code></pre>"},{"location":"api/tcp_test/#tabs-with-content","title":"Tabs with Content","text":"OverviewDetailsMore Info <p>This section gives you a high-level overview of the system.</p> <p>Here's where we break it down into components and logic.</p> <p>Links, references, and related topics go here.</p>"},{"location":"api/tcp_test/#sending-a-tcp-message","title":"Sending a TCP Message","text":"CLIPython <pre><code>docker-compose run --rm knsock send-tcp 172.18.0.2 8080 \"Hello TCP\"\n</code></pre> <p>Output: <pre><code>[TCP] Server response: Echo: Hello TCP\n</code></pre></p> <pre><code>from kn_sock import send_tcp_message\nsend_tcp_message('127.0.0.1', 8080, \"Hello TCP\")\n</code></pre> <p>Output: <pre><code>[TCP] Server response: Echo: Hello TCP\n</code></pre></p>"},{"location":"api/test/","title":"Tabs Test","text":"Tab 1Tab 2 <p>Content for tab 1.</p> <p>Content for tab 2.</p>"},{"location":"api/troubleshooting/","title":"Troubleshooting &amp; FAQ","text":"<p>Common issues, error messages, and solutions for working with kn-sock in Docker, Codespaces, and local environments.</p>"},{"location":"api/troubleshooting/#general-issues","title":"General Issues","text":"Issue Symptom/Output Solution/Workaround Port already in use <code>[Errno 98] Address already in use</code> Use a different port, or kill the process Hostname not found <code>[Errno -2] Name or service not known</code> Use the container/server IP, not a name Connection refused <code>ConnectionRefusedError</code> Make sure the server is running Missing dependency (libGL, etc.) <code>ImportError: libGL.so.1...</code> Install system packages (see below) Docker network not found <code>Error: network kn-sock_default not found</code> Recreate the network with <code>docker-compose up</code> Large file transfer fails Partial/incomplete transfer or disconnect Check disk space, increase timeouts No server response (UDP) No echo, no data returned UDP is connectionless; check ports/firewalls"},{"location":"api/troubleshooting/#docker-specific-issues","title":"Docker-Specific Issues","text":"Issue Symptom/Output Solution/Workaround Cannot reach service by name Hostname not found Use container IP (see <code>docker inspect ...</code>) GUI/X11 issues (live video/audio) No display, blank window Use local Python if GUI needed File permissions (file transfer) No file saved or permission denied Use directories with write access Orphan containers/network clutter Warnings about orphan containers Use <code>docker-compose down --remove-orphans</code>"},{"location":"api/troubleshooting/#system-dependencies","title":"System Dependencies","text":"<p>Some features require system libraries: - OpenCV/Video streaming: <code>libGL.so.1</code>, <code>libgthread-2.0.so.0</code>, and other dependencies - Audio streaming: <code>libportaudio2</code>, <code>alsa-utils</code>, etc.</p> <p>On Debian/Ubuntu-based systems, you may need: <pre><code>apt-get update &amp;&amp; apt-get install -y \\\n    libgl1 \\\n    libglib2.0-0 \\\n    libportaudio2 \\\n    portaudio19-dev \\\n    libasound2 \\\n    ffmpeg \\\n    gcc\n</code></pre></p>"},{"location":"api/troubleshooting/#how-to-find-container-ip","title":"How to Find Container IP","text":"<p><pre><code>docker ps  # Find your container ID\ndocker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' &lt;container_id&gt;\n</code></pre> Use this IP for client commands in Docker Compose.</p>"},{"location":"api/troubleshooting/#faq","title":"FAQ","text":"<p>Q: Why can't I use the service name as the host in Docker Compose? A: In <code>docker-compose run</code>, the new container is not on the same network by default. Use the server container\u2019s IP.</p> <p>Q: Why are my CLI commands hanging or failing? A: Confirm the server is running, port is correct, and network is open.</p> <p>Q: Why do I see import errors for system libraries? A: Install missing system packages, or use the provided Dockerfile.</p> <p>Q: How can I test two endpoints at once? A: Run each service (server/client) in its own terminal. For automation, write a shell script or use pytest with subprocess calls.</p> <p>Q: Where do I file bugs or ask for help? A: Open an issue on GitHub.</p>"},{"location":"archive/http/","title":"HTTP and HTTPS Utilities","text":"<p>kn-sock makes it easy to create minimal HTTP servers, issue GET/POST requests, and test HTTPS endpoints directly from the CLI or Python API.</p>"},{"location":"archive/http/#cli-commands","title":"CLI Commands","text":""},{"location":"archive/http/#1-start-a-minimal-http-server","title":"1. Start a Minimal HTTP Server","text":"<p>Spin up a simple HTTP server that serves static files and custom routes (for development/testing).</p> Command Description <code>run-http-server &lt;port&gt;</code> Start HTTP server on given port <p>Example: <pre><code>docker-compose run --rm knsock run-http-server 8000\n# Or: knsock run-http-server 8000\n</code></pre> Output: <pre><code>[HTTP][SYNC] Serving on 0.0.0.0:8000\n</code></pre></p>"},{"location":"archive/http/#2-http-get-request","title":"2. HTTP GET Request","text":"<p>Send a GET request to an HTTP server.</p> Command Description <code>http-get &lt;host&gt; &lt;port&gt; &lt;path&gt;</code> HTTP GET to endpoint <p>Example: <pre><code>docker-compose run --rm knsock http-get 172.18.0.2 8000 /\n</code></pre> Output: <pre><code>[HTTP][CLIENT] GET http://172.18.0.2:8000/\nHTTP/1.1 200 OK\n...\n&lt;response body&gt;\n</code></pre></p>"},{"location":"archive/http/#3-http-post-request","title":"3. HTTP POST Request","text":"<p>Send a POST request (with string data) to an HTTP server.</p> Command Description <code>http-post &lt;host&gt; &lt;port&gt; &lt;path&gt; &lt;data&gt;</code> HTTP POST to endpoint <p>Example: <pre><code>docker-compose run --rm knsock http-post 172.18.0.2 8000 / \"test=ok\"\n</code></pre> Output: <pre><code>[HTTP][CLIENT] POST http://172.18.0.2:8000/\nHTTP/1.1 200 OK\n...\n&lt;response body&gt;\n</code></pre></p>"},{"location":"archive/http/#4-https-getpost-requests","title":"4. HTTPS GET/POST Requests","text":"<p>Same as above, but with HTTPS.</p> Command Description <code>https-get &lt;host&gt; &lt;port&gt; &lt;path&gt;</code> HTTPS GET to endpoint <code>https-post &lt;host&gt; &lt;port&gt; &lt;path&gt; &lt;data&gt;</code> HTTPS POST to endpoint"},{"location":"archive/http/#options-table","title":"Options Table","text":"Option Description <code>&lt;port&gt;</code> Port number for server/client <code>&lt;host&gt;</code> IP or hostname of server <code>&lt;path&gt;</code> Path for GET/POST (e.g., /api, /) <code>&lt;data&gt;</code> Data to POST (as a string)"},{"location":"archive/http/#python-api","title":"Python API","text":""},{"location":"archive/http/#start-an-http-server","title":"Start an HTTP Server","text":"<pre><code>from kn_sock import start_http_server\n\ndef my_route_handler(request):\n    if request.path == \"/hello\":\n        return (200, \"text/plain\", b\"Hello, world!\")\n    return (404, \"text/plain\", b\"Not found\")\n\nstart_http_server(8000, routes={\"/hello\": my_route_handler})\n</code></pre>"},{"location":"archive/http/#http-getpost-client","title":"HTTP GET/POST (Client)","text":"<pre><code>from kn_sock import http_get, http_post\n\n# GET request\nstatus, headers, body = http_get(\"127.0.0.1\", 8000, \"/\")\n\n# POST request\nstatus, headers, body = http_post(\"127.0.0.1\", 8000, \"/\", \"name=knsock\")\n</code></pre>"},{"location":"archive/http/#sample-output","title":"Sample Output","text":"<p>HTTP server terminal: <pre><code>[HTTP][SYNC] Serving on 0.0.0.0:8000\n[HTTP][SERVER] GET / from ('172.18.0.1', 55123)\n</code></pre></p> <p>Client terminal: <pre><code>[HTTP][CLIENT] GET http://172.18.0.2:8000/\nHTTP/1.1 200 OK\nContent-Type: text/plain\nContent-Length: 14\n\nHello, world!\n</code></pre></p>"},{"location":"archive/http/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution Port already in use <code>[Errno 98] Address already in use</code> Use a different port or kill other process No response/404 <code>404 Not found</code> or empty output Check route/path; static only by default HTTPS errors SSL certificate errors Use valid/test certs or skip verification Hostname not found <code>[Errno -2] Name or service not known</code> Use container IP for Docker setups"},{"location":"archive/http/#testing","title":"Testing","text":""},{"location":"archive/http/#manual-test","title":"Manual Test","text":"<p>Start server: <pre><code>docker-compose run --rm knsock run-http-server 8000\n</code></pre></p> <p>In another terminal, run: <pre><code>docker-compose run --rm knsock http-get &lt;server-ip&gt; 8000 /\n# Example: http-get 172.18.0.2 8000 /\n</code></pre></p> <p>Check for 200 OK and the expected response body.</p>"},{"location":"archive/tcp/","title":"TCP Utilities","text":"<p>kn-sock provides both CLI and Python APIs for working with TCP servers and clients. Use these commands to build, test, and automate network communication.</p>"},{"location":"archive/tcp/#function-index","title":"Function Index","text":"Function/Class Description start_tcp_server Start a basic synchronous TCP server for single-connection, blocking I/O. Use for simple demos or network testing. start_threaded_tcp_server Multithreaded TCP server that spawns a thread per client. Best for serving multiple simultaneous connections with blocking I/O. send_tcp_message Synchronous TCP client: connects, sends a string, and logs the response (does not return it). For basic text protocols. send_tcp_bytes Synchronous TCP client for sending raw bytes (binary payloads), logging any server response. Useful for custom protocols. start_async_tcp_server Async TCP server using asyncio. Efficiently handles many connections in a single event loop. Recommended for async workloads. send_tcp_message_async Async TCP client: sends a string and logs the server response without blocking. Ideal for non-blocking client logic. TCPConnectionPool Thread-safe pool for managing/reusing TCP (and SSL) connections. Improves performance for high-throughput or threaded apps. start_ssl_tcp_server Synchronous SSL/TLS TCP server, with support for client cert verification (mTLS). Use for encrypted, authenticated communication. send_ssl_tcp_message Synchronous SSL/TLS client: connects, sends a string, logs the response. Secure text-based messaging. start_async_ssl_tcp_server Async SSL/TLS TCP server using asyncio. Handles encrypted connections concurrently in a secure event loop. send_ssl_tcp_message_async Async SSL/TLS client: connects, sends a string, and logs the response asynchronously. Best for secure non-blocking clients."},{"location":"archive/tcp/#cli-commands","title":"CLI Commands","text":""},{"location":"archive/tcp/#1-run-a-tcp-echo-server","title":"1. Run a TCP Echo Server","text":"<p>Spin up a basic echo server that listens for text messages and replies with \u201cEcho: ...\u201d</p> Command Description <code>run-tcp-server &lt;port&gt;</code> Start a TCP echo server <p>Example: <pre><code>docker-compose run --rm knsock run-tcp-server 8080\n# Or (with pip): knsock run-tcp-server 8080\n</code></pre> Output: <pre><code>[TCP] Server listening on 0.0.0.0:8080\n</code></pre></p>"},{"location":"archive/tcp/#2-send-a-tcp-message","title":"2. Send a TCP Message","text":"<p>Connect to a TCP server and send a text message.</p> Command Description <code>send-tcp &lt;host&gt; &lt;port&gt; &lt;message&gt;</code> Send a message via TCP <p>Example: <pre><code>docker-compose run --rm knsock send-tcp 172.18.0.2 8080 \"Hello TCP\"\n</code></pre> Output: <pre><code>[TCP] Server response: Echo: Hello TCP\n</code></pre></p> <p>How to Get the Container Name or ID</p> <p>Run <code>docker ps</code> to list running containers. The last column (<code>NAMES</code>) is the container name.</p> <p>Example output: <pre><code>CONTAINER ID   IMAGE         ...   NAMES\nc8abcb1a321d   knsock_knsock ...  knsock_knsock_run-tcp-server_1\n</code></pre></p> <p>Use this name or the CONTAINER ID in <code>docker inspect</code> to get the IP address.</p> <p>How to Find the Server IP in Docker</p> <p>Replace <code>172.18.0.2</code> with the IP address of your running TCP server container.</p> <p>You can find the container's IP by running: <pre><code>docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' &lt;container_name_or_id&gt;\n</code></pre></p> <p>Use this IP as the <code>&lt;host&gt;</code> parameter for the <code>send-tcp</code> command.</p>"},{"location":"archive/tcp/#options-table","title":"Options Table","text":"Option Description <code>&lt;port&gt;</code> Port number for server/client <code>&lt;host&gt;</code> IP or hostname of server (client only) <code>&lt;message&gt;</code> Message to send (client only)"},{"location":"archive/tcp/#python-api-usage-examples","title":"Python API Usage Examples","text":""},{"location":"archive/tcp/#start-a-tcp-server","title":"Start a TCP Server","text":"<pre><code>from kn_sock import start_tcp_server\n\ndef echo_handler(data, addr, conn):\n    print(f\"Received from {addr}: {data.decode()}\")\n    conn.sendall(b\"Echo: \" + data)\n\nstart_tcp_server(8080, echo_handler)\n</code></pre>"},{"location":"archive/tcp/#send-a-tcp-message","title":"Send a TCP Message","text":"<pre><code>from kn_sock import send_tcp_message\nsend_tcp_message('127.0.0.1', 8080, \"Hello TCP\")\n</code></pre>"},{"location":"archive/tcp/#sample-output","title":"Sample Output","text":"<p>Server terminal: <pre><code>[TCP] Server listening on 0.0.0.0:8080\n[TCP][SERVER] Received from ('172.18.0.1', 49906): b'Hello TCP'\n</code></pre></p> <p>Client terminal: <pre><code>[TCP] Server response: Echo: Hello TCP\n</code></pre></p>"},{"location":"archive/tcp/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution Port already in use <code>OSError: [Errno 98] Address in use</code> Use a different port or kill the existing process Docker: \u201cConnection refused\u201d <code>ConnectionRefusedError</code> Ensure server is running and reachable Hostname not found <code>[Errno -2] Name or service not known</code> Use container IP, not name (get with <code>docker inspect ...</code>)"},{"location":"archive/tcp/#testing","title":"Testing","text":""},{"location":"archive/tcp/#manual-test","title":"Manual Test","text":"<p>In one terminal: <pre><code>docker-compose run --rm knsock run-tcp-server 8080\n</code></pre></p> <p>In another terminal: <pre><code># Replace &lt;server-ip&gt; with your actual server IP\ndocker-compose run --rm knsock send-tcp &lt;server-ip&gt; 8080 \"Hello TCP\"\n# Example:\ndocker-compose run --rm knsock send-tcp 172.18.0.2 8080 \"Hello TCP\"\n</code></pre></p> <p>If you see the following in your client terminal, the test passes:</p> <p><code>[TCP] Server response: Echo: Hello TCP</code></p>"},{"location":"archive/tcp/#python-api-reference","title":"Python API Reference","text":""},{"location":"archive/tcp/#api-quickstart","title":"API Quickstart","text":"<pre><code>... Short how-to code blocks for common usage ...\n</code></pre>"},{"location":"archive/tcp/#tcp-server-apis","title":"TCP Server APIs","text":""},{"location":"archive/tcp/#synchronous","title":"Synchronous","text":"<p>Starts a synchronous TCP server (IPv4/IPv6 supported).</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle (data, addr, client_socket).</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6).</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, server will exit when event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket fails.</p> <code>error</code> <p>For general network errors.</p> Example <p>def echo_handler(data, addr, sock): ...     print(data) ...     sock.sendall(data) start_tcp_server(8080, echo_handler)</p> <p>Starts a multithreaded TCP server (IPv4/IPv6 supported).</p> <p>This function listens for incoming TCP connections on the specified port, spawning a new thread for each client. The handler function is called for each message received from a client.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle incoming data. Signature: (data: bytes, addr: tuple, client_socket: socket.socket) -&gt; None</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>error</code> <p>For network-related errors.</p> Example <p>def echo_handler(data, addr, sock): ...     print(f\"From {addr}: {data}\") ...     sock.sendall(b\"Echo: \" + data) import threading shutdown = threading.Event() start_threaded_tcp_server(8080, echo_handler, shutdown_event=shutdown)</p>"},{"location":"archive/tcp/#asynchronous","title":"Asynchronous","text":"<p>Starts an asynchronous TCP server (IPv4/IPv6 supported).</p> <p>Listens for incoming TCP connections on the specified port using asyncio, spawning a coroutine for each client. The handler function is called with received data, the client address, and the StreamWriter for responses. Supports graceful shutdown when a shutdown_event is set.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>Async function to handle incoming data. Signature: (data: bytes, addr: tuple, writer: asyncio.StreamWriter) -&gt; Awaitable[None]</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>CancelledError</code> <p>If the server task is cancelled.</p> Example <p>import asyncio async def echo_handler(data, addr, writer): ...     print(f\"Received from {addr}: {data.decode()}\") ...     writer.write(b\"Echo: \" + data) ...     await writer.drain() asyncio.run(start_async_tcp_server(8080, echo_handler))</p>"},{"location":"archive/tcp/#tcp-client-apis","title":"TCP Client APIs","text":""},{"location":"archive/tcp/#synchronous_1","title":"Synchronous","text":"<p>Sends a message to a TCP server (IPv4/IPv6 supported) and logs the server's response.</p> <p>Opens a TCP connection to the specified host and port, sends the given message as UTF-8 bytes, and logs the server's response (if any) to the logger. This function does not return the server's response.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_tcp_message(\"localhost\", 8080, \"hello world\")</p> <p>Sends raw bytes to a TCP server and logs the response.</p> <p>Opens a TCP connection to the specified host and port, sends the given data as-is (no encoding), and logs the server's response (if any) as bytes. This function does not return the response.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>data</code> <code>bytes</code> <p>The data to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_tcp_bytes(\"127.0.0.1\", 8080, b\"ping\")</p>"},{"location":"archive/tcp/#asynchronous_1","title":"Asynchronous","text":"<p>Sends a message to a TCP server asynchronously and returns the response.</p> <p>Opens an asynchronous TCP connection to the specified host and port, sends the given message as UTF-8 bytes, and awaits the server's response as a string. Returns None if no response is received.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>import asyncio response = asyncio.run(send_tcp_message_async(\"localhost\", 8080, \"hello async\")) print(response) Echo: hello async</p>"},{"location":"archive/tcp/#connection-pools","title":"Connection Pools","text":"<p>Thread-safe TCP/SSL connection pool for efficient reuse of socket connections.</p> <p>Manages a pool of TCP or SSL connections to a given host and port, allowing multiple threads to acquire and release connections as needed. The pool automatically closes idle connections after a configurable timeout.</p> <p>Typical usage:</p> <pre><code>&gt;&gt;&gt; pool = TCPConnectionPool(\"localhost\", 8080, max_size=5, idle_timeout=30)\n&gt;&gt;&gt; with pool.connection() as conn:\n...     conn.sendall(b\"ping\")\n...     response = conn.recv(1024)\n&gt;&gt;&gt; pool.closeall()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>max_size</code> <code>int</code> <p>Maximum number of concurrent connections. Defaults to 5.</p> <code>5</code> <code>idle_timeout</code> <code>int</code> <p>Seconds before idle connections are closed. Defaults to 30.</p> <code>30</code> <code>ssl</code> <code>bool</code> <p>Whether to use SSL/TLS for connections. Defaults to False.</p> <code>False</code> <code>cafile</code> <code>str</code> <p>Path to CA certificate for SSL/TLS verification.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to client certificate for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to client private key for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Methods:</p> Name Description <code>connection</code> <p>Acquire a connection from the pool as a context manager.</p> <code>closeall</code> <p>Close all connections and clear the pool.</p> Notes <ul> <li>Connections are managed in a thread-safe manner using an internal lock.</li> <li>Idle connections are closed and removed from the pool after <code>idle_timeout</code> seconds.</li> <li>When <code>max_size</code> is reached, additional requests block until a connection is released.</li> </ul> Example <p>pool = TCPConnectionPool(\"localhost\", 8080, ssl=True, cafile=\"ca.pem\") with pool.connection() as conn: ...     conn.sendall(b\"hello\") ...     print(conn.recv(1024)) pool.closeall()</p>"},{"location":"archive/tcp/#ssltls-server","title":"SSL/TLS Server","text":""},{"location":"archive/tcp/#synchronous_2","title":"Synchronous","text":"<p>Starts a synchronous SSL/TLS TCP server with optional client certificate verification.</p> <p>Listens for incoming SSL/TLS connections on the specified port. For each client connection, wraps the socket with SSL/TLS, then invokes the handler function with the received data, client address, and SSL socket. Supports IPv4 and IPv6.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle incoming data. Signature: (data: bytes, addr: tuple, ssl_sock: ssl.SSLSocket) -&gt; None</p> required <code>certfile</code> <code>str</code> <p>Path to the server certificate file in PEM format.</p> required <code>keyfile</code> <code>str</code> <p>Path to the server private key file in PEM format.</p> required <code>cafile</code> <code>str</code> <p>Path to CA certificate for verifying client certificates.</p> <code>None</code> <code>require_client_cert</code> <code>bool</code> <p>Whether to require client certificates for mutual TLS. Defaults to False.</p> <code>False</code> <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>SSLError</code> <p>For SSL/TLS handshake or certificate errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>def echo_handler(data, addr, ssl_sock): ...     print(f\"Received from {addr}: {data}\") ...     ssl_sock.sendall(b\"Echo: \" + data) start_ssl_tcp_server( ...     port=8443, ...     handler_func=echo_handler, ...     certfile=\"server.pem\", ...     keyfile=\"server-key.pem\" ... )</p>"},{"location":"archive/tcp/#asynchronous_2","title":"Asynchronous","text":"<p>Starts an asynchronous SSL/TLS TCP server with optional client certificate verification.</p> <p>Listens for incoming SSL/TLS connections using asyncio on the specified port. For each client, wraps the connection with SSL/TLS and invokes the provided async handler function with the received data, client address, and StreamWriter. Supports IPv4 and IPv6, as well as graceful shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>Async function to handle incoming data. Signature: (data: bytes, addr: tuple, writer: asyncio.StreamWriter) -&gt; Awaitable[None]</p> required <code>certfile</code> <code>str</code> <p>Path to the server certificate file in PEM format.</p> required <code>keyfile</code> <code>str</code> <p>Path to the server private key file in PEM format.</p> required <code>cafile</code> <code>str</code> <p>Path to CA certificate for verifying client certificates.</p> <code>None</code> <code>require_client_cert</code> <code>bool</code> <p>Whether to require client certificates for mutual TLS. Defaults to False.</p> <code>False</code> <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>SSLError</code> <p>For SSL/TLS handshake or certificate errors.</p> <code>CancelledError</code> <p>If the server task is cancelled.</p> Example <p>import asyncio async def echo_handler(data, addr, writer): ...     print(f\"Received from {addr}: {data.decode()}\") ...     writer.write(b\"Echo: \" + data) ...     await writer.drain() asyncio.run(start_async_ssl_tcp_server( ...     port=8443, ...     handler_func=echo_handler, ...     certfile=\"server.pem\", ...     keyfile=\"server-key.pem\" ... ))</p>"},{"location":"archive/tcp/#ssltls-client","title":"SSL/TLS Client","text":""},{"location":"archive/tcp/#synchronous_3","title":"Synchronous","text":"<p>Sends a message to an SSL/TLS TCP server and returns the response.</p> <p>Opens a secure SSL/TLS connection to the specified host and port, sends the given message as UTF-8 bytes, and returns the server's response as a string if one is received. Supports server verification and mutual TLS.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <code>cafile</code> <code>str</code> <p>Path to a CA certificate file for verifying the server.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to the client certificate file for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to the client private key file for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>SSLError</code> <p>For SSL/TLS handshake or verification errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_ssl_tcp_message( ...     host=\"localhost\", ...     port=8443, ...     message=\"secure hello\", ...     cafile=\"ca.pem\" ... ) 'Echo: secure hello'</p>"},{"location":"archive/tcp/#asynchronous_3","title":"Asynchronous","text":"<p>Sends a message to an SSL/TLS TCP server asynchronously and returns the response.</p> <p>Opens an asynchronous SSL/TLS connection to the specified host and port, sends the given message as UTF-8 bytes, and awaits the server's response as a string. Supports server verification and mutual TLS authentication.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <code>cafile</code> <code>str</code> <p>Path to a CA certificate file for verifying the server.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to the client certificate file for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to the client private key file for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>SSLError</code> <p>For SSL/TLS handshake or verification errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>import asyncio response = asyncio.run( ...     send_ssl_tcp_message_async( ...         host=\"localhost\", ...         port=8443, ...         message=\"secure async hello\", ...         cafile=\"ca.pem\" ...     ) ... ) print(response) Echo: secure async hello</p>"},{"location":"archive/udp/","title":"UDP Utilities","text":"<p>kn-sock provides CLI commands and Python APIs for working with UDP servers and clients. Use these tools to send and receive datagrams for network testing, diagnostics, or lightweight communication.</p>"},{"location":"archive/udp/#cli-commands","title":"CLI Commands","text":""},{"location":"archive/udp/#1-run-a-udp-echo-server","title":"1. Run a UDP Echo Server","text":"<p>Start a simple UDP server that listens for messages and echoes them back.</p> Command Description <code>run-udp-server &lt;port&gt;</code> Start a UDP echo server <p>Example: <pre><code>docker-compose run --rm knsock run-udp-server 8081\n# Or (with pip): knsock run-udp-server 8081\n</code></pre> Output: <pre><code>[UDP][SYNC] Listening on 0.0.0.0:8081\n</code></pre></p>"},{"location":"archive/udp/#2-send-a-udp-message","title":"2. Send a UDP Message","text":"<p>Send a datagram to a UDP server.</p> Command Description <code>send-udp &lt;host&gt; &lt;port&gt; &lt;message&gt;</code> Send a UDP datagram <p>Example: <pre><code>docker-compose run --rm knsock send-udp 172.18.0.2 8081 \"Hello UDP\"\n</code></pre> Output: <pre><code>[UDP][SYNC] Sent to 172.18.0.2:8081\n</code></pre></p>"},{"location":"archive/udp/#options-table","title":"Options Table","text":"Option Description <code>&lt;port&gt;</code> Port number for server/client <code>&lt;host&gt;</code> IP or hostname of server (client only) <code>&lt;message&gt;</code> Message to send (client only)"},{"location":"archive/udp/#python-api","title":"Python API","text":""},{"location":"archive/udp/#start-a-udp-server","title":"Start a UDP Server","text":"<pre><code>from kn_sock import start_udp_server\n\ndef echo_handler(data, addr, sock):\n    print(f\"Received from {addr}: {data.decode()}\")\n    sock.sendto(b\"Echo: \" + data, addr)\n\nstart_udp_server(8081, echo_handler)\n</code></pre>"},{"location":"archive/udp/#send-a-udp-message","title":"Send a UDP Message","text":"<pre><code>from kn_sock import send_udp_message\nsend_udp_message('127.0.0.1', 8081, \"Hello UDP\")\n</code></pre>"},{"location":"archive/udp/#sample-output","title":"Sample Output","text":"<p>Server terminal: <pre><code>[UDP][SYNC] Listening on 0.0.0.0:8081\n[UDP][SERVER] Received from ('172.18.0.1', 54321): Hello UDP\n</code></pre></p> <p>Client terminal: <pre><code>[UDP][SYNC] Sent to 172.18.0.2:8081\n</code></pre></p>"},{"location":"archive/udp/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution No server response No message echoed to client UDP is connectionless; confirm ports and firewall Docker: connection refused <code>ConnectionRefusedError</code> Check that the server is running and reachable Hostname not found <code>[Errno -2] Name or service not known</code> Use container IP, not name"},{"location":"archive/udp/#testing","title":"Testing","text":""},{"location":"archive/udp/#manual-test","title":"Manual Test","text":"<p>In one terminal: <pre><code>docker-compose run --rm knsock run-udp-server 8081\n</code></pre></p> <p>In another terminal: <pre><code>docker-compose run --rm knsock send-udp &lt;server-ip&gt; 8081 \"Hello UDP\"\n# Example: send-udp 172.18.0.2 8081 \"Hello UDP\"\n</code></pre></p> <p>Check the server terminal for the received message and confirm that the client output shows it was sent successfully.</p>"},{"location":"archive/websocket/","title":"WebSocket Utilities","text":"<p>kn-sock provides CLI and Python APIs for real-time WebSocket communication for chat, real-time dashboards, or browser-to-server data flows.</p>"},{"location":"archive/websocket/#cli-commands","title":"CLI Commands","text":""},{"location":"archive/websocket/#1-start-a-websocket-echo-server","title":"1. Start a WebSocket Echo Server","text":"<p>Launch a WebSocket server that listens for incoming connections and echoes any messages received.</p> Command Description <code>run-websocket-server &lt;port&gt;</code> Start WebSocket echo server <p>Example: <pre><code>docker-compose run --rm knsock run-websocket-server 9000\n# Or: knsock run-websocket-server 9000\n</code></pre> Output: <pre><code>[WebSocket][SERVER] Listening on 0.0.0.0:9000\n</code></pre></p>"},{"location":"archive/websocket/#2-websocket-client","title":"2. WebSocket Client","text":"<p>Connect to a WebSocket server, send a message, and display the server\u2019s response.</p> Command Description <code>websocket-client &lt;host&gt; &lt;port&gt; &lt;message&gt;</code> Connect/send/receive via WebSocket <p>Example: <pre><code>docker-compose run --rm knsock websocket-client 172.18.0.2 9000 \"Hello WebSocket\"\n</code></pre> Output: <pre><code>[WebSocket][CLIENT] Connected to ws://172.18.0.2:9000\n[WebSocket][CLIENT] Sent: Hello WebSocket\n[WebSocket][CLIENT] Received: Echo: Hello WebSocket\n</code></pre></p>"},{"location":"archive/websocket/#options-table","title":"Options Table","text":"Option Description <code>&lt;port&gt;</code> Port number for server/client <code>&lt;host&gt;</code> IP or hostname of server <code>&lt;message&gt;</code> Message to send (client only)"},{"location":"archive/websocket/#python-api","title":"Python API","text":""},{"location":"archive/websocket/#start-a-websocket-server","title":"Start a WebSocket Server","text":"<pre><code>from kn_sock import start_websocket_server\n\ndef echo_handler(ws, addr):\n    for msg in ws:\n        print(f\"Received: {msg}\")\n        ws.send(\"Echo: \" + msg)\n\nstart_websocket_server(9000, echo_handler)\n</code></pre>"},{"location":"archive/websocket/#connect-as-websocket-client","title":"Connect as WebSocket Client","text":"<pre><code>from kn_sock import connect_websocket\n\nws = connect_websocket('127.0.0.1', 9000)\nws.send(\"Hello WebSocket\")\nresponse = ws.recv()\nprint(response)\nws.close()\n</code></pre>"},{"location":"archive/websocket/#sample-output","title":"Sample Output","text":"<p>Server terminal: <pre><code>[WebSocket][SERVER] Listening on 0.0.0.0:9000\n[WebSocket][SERVER] Connection from ('172.18.0.1', 33512)\n[WebSocket][SERVER] Received: Hello WebSocket\n</code></pre></p> <p>Client terminal: <pre><code>[WebSocket][CLIENT] Connected to ws://172.18.0.2:9000\n[WebSocket][CLIENT] Sent: Hello WebSocket\n[WebSocket][CLIENT] Received: Echo: Hello WebSocket\n</code></pre></p>"},{"location":"archive/websocket/#known-issues-troubleshooting","title":"Known Issues &amp; Troubleshooting","text":"Issue Symptom/Output Solution Port already in use <code>[Errno 98] Address already in use</code> Use a different port or kill existing process Connection refused <code>ConnectionRefusedError</code> Start the server before connecting Hostname not found <code>[Errno -2] Name or service not known</code> Use container IP, not name, in Docker setups Browser client can't connect No handshake or failed connection Ensure proper port, firewall, and server up"},{"location":"archive/websocket/#testing","title":"Testing","text":""},{"location":"archive/websocket/#manual-test","title":"Manual Test","text":"<p>Start the WebSocket server: <pre><code>docker-compose run --rm knsock run-websocket-server 9000\n</code></pre></p> <p>In another terminal: <pre><code>docker-compose run --rm knsock websocket-client &lt;server-ip&gt; 9000 \"Hello WebSocket\"\n# Example: websocket-client 172.18.0.2 9000 \"Hello WebSocket\"\n</code></pre></p> <p>Confirm that the client receives <code>Echo: Hello WebSocket</code>.</p>"},{"location":"cli/","title":"Using the CLI","text":"<p>The knsock command-line interface provides quick access to all TCP, UDP, and WebSocket tools. It's built using Typer, giving it a structured syntax and automatic help output.</p> <p>Run all commands using either knsock (if installed via pip) or via Docker.</p>"},{"location":"cli/#cli-structure","title":"CLI Structure","text":"<pre><code>knsock [PROTOCOL] [COMMAND] [OPTIONS]\n</code></pre>"},{"location":"cli/#supported-protocols","title":"Supported Protocols","text":"<ul> <li>tcp \u2013 Synchronous and multithreaded TCP servers and clients</li> <li>udp \u2013 Synchronous UDP echo server and datagram sender</li> <li>websocket \u2013 WebSocket echo server and client message sender</li> </ul>"},{"location":"cli/#top-level-help","title":"Top-Level Help","text":"<pre><code>knsock --help\n</code></pre> <p>Output:</p> <pre><code>Usage: knsock [OPTIONS] COMMAND [ARGS]...\n\n  knsock: Network testing CLI for TCP, UDP, and WebSocket.\n\nOptions:\n  --help  Show this message and exit.\n\nCommands:\n  tcp        TCP servers and clients\n  udp        UDP servers and clients\n  websocket  WebSocket servers and clients\n</code></pre>"},{"location":"cli/#run-from-docker","title":"Run from Docker","text":"<pre><code>docker-compose run --rm knsock --help\n</code></pre>"},{"location":"cli/#use-case","title":"Use Case","text":"<p>Use the CLI when you need:</p> <ul> <li>Quick network diagnostics</li> <li>Shell scripting or automation</li> <li>Rapid testing without writing Python code</li> <li>Consistent interface across protocols</li> </ul>"},{"location":"cli/#example","title":"Example","text":"<p>Start a TCP echo server:</p> <pre><code>knsock tcp run-server 9000\n</code></pre> <p>Send a message:</p> <pre><code>knsock tcp send localhost 9000 \"Hello CLI\"\n</code></pre>"},{"location":"cli/#related-pages","title":"Related Pages","text":"<ul> <li>TCP CLI</li> <li>UDP CLI</li> <li>WebSocket CLI</li> </ul>"},{"location":"guides/interactive_cli/","title":"Interactive TCP Shell","text":"<p>Use the <code>knsock interactive</code> shell to connect to multiple TCP endpoints and test message flows live. This tool is helpful for demos, debugging, and exploring server behavior during development.</p> <p>Note</p> <p>Currently supports only TCP. WebSocket or UDP extensions may be added later.</p>"},{"location":"guides/interactive_cli/#features","title":"Features","text":"<ul> <li>Connect to named TCP endpoints</li> <li>Send and receive UTF\u20118 messages</li> <li>Switch between multiple connections</li> <li>View message history</li> <li>Toggle background receive mode</li> <li>Gracefully disconnect or quit</li> </ul>"},{"location":"guides/interactive_cli/#commands","title":"Commands","text":"Command Description <code>connect</code> Connect to a TCP server and name the connection <code>list</code> List all active connections <code>select</code> Choose a default connection for sending/receiving <code>send</code> Send a UTF-8 message to the selected connection <code>receive</code> Receive a UTF-8 message manually <code>bg_receive</code> Toggle auto-receive mode (runs in background) <code>history</code> Show last 10 messages sent/received <code>disconnect</code> Close and remove a connection <code>quit</code> / <code>exit</code> Exit the shell and close all connections <code>help</code> Show command help"},{"location":"guides/interactive_cli/#how-to-launch","title":"How to Launch","text":"<pre><code>python3 -m kn_sock.interactive_cli\n</code></pre>"},{"location":"guides/interactive_cli/#before-you-start","title":"Before You Start","text":"<p>The interactive CLI connects to existing TCP servers. To test it locally, create a simple TCP echo server using the Python API:</p> <pre><code># echo_server.py\nfrom kn_sock import start_tcp_server\n\ndef echo(data, addr, conn):\n    print(f\"Connection from {addr}\")\n    try:\n        print(f\"Received: {data}\")\n        conn.sendall(b\"Echo: \" + data)\n    except Exception as e:\n        print(f\"Error: {e}\")\n    finally:\n        conn.close()\n        print(f\"Closed connection to {addr}\")\n\nstart_tcp_server(9001, echo, host=\"0.0.0.0\")\n</code></pre> <p>Note</p> <p>You can also use the prebuilt <code>echo_server.py</code> file included in the project root for testing. It uses the same handler function shown above and listens on port 9001.</p> <p>Run it in a separate terminal:</p> <pre><code>python3 echo_server.py\n</code></pre> <p>Then launch the interactive CLI in another terminal:</p> <pre><code>python3 -m kn_sock.interactive_cli\n</code></pre> <p>And try the following:</p> <pre><code>(kn-sock) connect local 127.0.0.1 9001\n(kn-sock) send hello\n(kn-sock) receive\n</code></pre>"},{"location":"guides/interactive_cli/#example-session","title":"Example Session","text":"<pre><code>(kn-sock) connect local 127.0.0.1 9001\nConnected to 127.0.0.1:9001 as \"local\".\n\n(kn-sock) send hello\nMessage sent.\n\n(kn-sock) receive\nReceived: Echo: hello\n\n(kn-sock) quit\nExiting kn-sock interactive CLI.\n</code></pre> <p>Info</p> <p>The <code>echo_server.py</code> handler closes the connection after replying. For persistent sessions, modify the handler to keep the connection open.</p>"},{"location":"guides/interactive_cli/#when-to-use","title":"When to Use","text":"<p>Use the interactive shell when you want to:</p> <ul> <li>Manually test one or more TCP endpoints</li> <li>Observe live message exchange</li> <li>Run quick ad hoc experiments during QA</li> <li>Demonstrate app behavior during dev sessions</li> </ul>"},{"location":"guides/interactive_cli/#related-pages","title":"Related Pages","text":"<ul> <li>TCP Python API</li> <li>TCP CLI Reference</li> <li>TCP Testing</li> </ul>"},{"location":"http/","title":"HTTP and HTTPS Utilities","text":"<p>kn-sock makes it easy to create minimal HTTP servers, issue GET/POST requests, and test HTTPS endpoints directly from the CLI or Python API.</p>"},{"location":"http/#function-index","title":"Function\u202fIndex","text":"Function/Class Description start_http_server Start a minimal synchronous HTTP server that serves static files and custom routes http_get Perform an HTTP\u202fGET request http_post Perform an HTTP\u202fPOST request https_get Perform an HTTPS\u202fGET request https_post Perform an HTTPS\u202fPOST request"},{"location":"http/#related-topics","title":"Related Topics","text":"<ul> <li>CLI commands</li> <li>Python API</li> <li>Reference</li> <li>Testing &amp; Troubleshooting</li> </ul>"},{"location":"http/cli/","title":"HTTP: Using the CLI","text":""},{"location":"http/cli/#cli-commands","title":"CLI Commands","text":""},{"location":"http/cli/#1-start-a-minimal-http-server","title":"1. Start a Minimal HTTP Server","text":"<p>Spin up a simple HTTP server that serves static files and custom routes (for development/testing).</p> Command Description <code>run-http-server &lt;port&gt;</code> Start HTTP server on given port <p>Example <pre><code>docker-compose run --rm knsock run-http-server 8000\n# Or: knsock run-http-server 8000\n</code></pre></p> <p>Output</p> <pre><code>[HTTP][SYNC] Serving on 0.0.0.0:8000\n</code></pre>"},{"location":"http/cli/#2-http-get-request","title":"2. HTTP\u202fGET Request","text":"<p>Send a GET request to an HTTP server.</p> Command Description <code>http-get &lt;host&gt; &lt;port&gt; &lt;path&gt;</code> HTTP\u202fGET to endpoint <p>Example</p> <pre><code>docker-compose run --rm knsock http-get 172.18.0.2 8000 /\n</code></pre> <p>Output</p> <pre><code>[HTTP][CLIENT] GET http://172.18.0.2:8000/\nHTTP/1.1 200 OK\n...\n&lt;response body&gt;\n</code></pre>"},{"location":"http/cli/#3-http-post-request","title":"3. HTTP\u202fPOST Request","text":"<p>Send a POST request (with string data) to an HTTP server.</p> Command Description <code>http-post &lt;host&gt; &lt;port&gt; &lt;path&gt; &lt;data&gt;</code> HTTP\u202fPOST to endpoint <p>Example</p> <pre><code>docker-compose run --rm knsock http-post 172.18.0.2 8000 / \"test=ok\"\n</code></pre> <p>Output</p> <pre><code>[HTTP][CLIENT] POST http://172.18.0.2:8000/\nHTTP/1.1 200 OK\n...\n&lt;response body&gt;\n</code></pre>"},{"location":"http/cli/#4-https-getpost-requests","title":"4. HTTPS\u202fGET/POST Requests","text":"<p>Same as above, but with HTTPS.</p> Command Description <code>https-get &lt;host&gt; &lt;port&gt; &lt;path&gt;</code> HTTPS\u202fGET to endpoint <code>https-post &lt;host&gt; &lt;port&gt; &lt;path&gt; &lt;data&gt;</code> HTTPS\u202fPOST to endpoint"},{"location":"http/cli/#options","title":"Options","text":"Option Description <code>&lt;port&gt;</code> Port number for server/client <code>&lt;host&gt;</code> IP or hostname of server <code>&lt;path&gt;</code> Path for GET/POST (for example, /) <code>&lt;data&gt;</code> Data to POST (as a string)"},{"location":"http/cli/#related-topics","title":"Related Topics","text":"<ul> <li>Python API</li> <li>Reference</li> <li>Testing &amp; Troubleshooting</li> </ul>"},{"location":"http/python-api/","title":"HTTP Python API","text":"<p>Use the kn\u2011sock Python API to launch lightweight HTTP servers and issue GET/POST requests directly in code.</p>"},{"location":"http/python-api/#start-an-http-server","title":"Start an HTTP Server","text":"<pre><code>from kn_sock import start_http_server\n\ndef hello_handler(request, sock):\n    sock.sendall(b\"HTTP/1.1 200 OK\\r\\nContent-Length: 5\\r\\n\\r\\nHello\")\n\nstart_http_server(\n    host=\"0.0.0.0\",\n    port=8000,\n    routes={(\"GET\", \"/hello\"): hello_handler}\n)\n</code></pre> <p>This starts a synchronous HTTP server that:</p> <ul> <li>Binds to 0.0.0.0:8000</li> <li>Responds to GET /hello with Hello</li> <li>Unmatched paths return 404 Not Found unless you provide a static_dir.</li> </ul>"},{"location":"http/python-api/#send-http-get-post-requests","title":"Send HTTP GET / POST Requests","text":"<pre><code>from kn_sock import http_get, http_post\n\n# GET request\nbody = http_get(\"localhost\", 8000, \"/hello\")\nprint(body)\n\n# POST request\nbody = http_post(\"localhost\", 8000, \"/\", \"name=knsock\")\nprint(body)\n</code></pre> <p>Both functions return the response body as a UTF-8 decoded string. You can optionally include headers as a dict.</p>"},{"location":"http/python-api/#send-https-get-post-requests","title":"Send HTTPS GET / POST Requests","text":"<pre><code>from kn_sock import https_get, https_post\n\n# Basic GET request\nbody = https_get(\"example.com\", 443, \"/\")\nprint(body)\n\n# POST request with CA verification\nbody = https_post(\n    \"example.com\",\n    443,\n    \"/submit\",\n    \"name=test\",\n    cafile=\"/etc/ssl/certs/ca-certificates.crt\"\n)\nprint(body)\n</code></pre> <p>The cafile argument is optional. If omitted, the system\u2019s default certificate chain is used. If verification fails, an ssl.SSLError is raised.</p>"},{"location":"http/python-api/#example-output","title":"Example Output","text":"<p>Server terminal</p> <pre><code>[HTTP][SERVER] Listening on 0.0.0.0:8000\n[HTTP][SERVER] GET /hello from ('127.0.0.1', 56244)\n</code></pre> <p>Client output</p> <pre><code>Hello\n</code></pre>"},{"location":"http/python-api/#when-to-use-the-python-api","title":"When to Use the Python API","text":"<p>Use the Python API when:</p> <ul> <li>You're embedding server functionality inside your application</li> <li>You want to send test requests without invoking the CLI</li> <li>You\u2019re scripting interactions or chaining together HTTP utilities</li> </ul> <p>For CLI usage, see the CLI commands page.</p>"},{"location":"http/python-api/#related-topics","title":"Related Topics","text":"<ul> <li>CLI commands</li> <li>Reference</li> <li>Testing &amp; Troubleshooting</li> </ul>"},{"location":"http/reference/","title":"API Reference","text":"<p>This page documents all public functions available in the <code>kn_sock.http</code> module. You can use these directly in your Python applications or scripts.</p>"},{"location":"http/reference/#http-client-apis","title":"HTTP Client APIs","text":""},{"location":"http/reference/#kn_sock.http.http_get","title":"<code>http_get(host: str, port: int = 80, path: str = '/', headers: Optional[Dict[str, str]] = None) -&gt; str</code>","text":"<p>Send a synchronous HTTP GET request.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Server hostname or IP address.</p> required <code>port</code> <code>int</code> <p>Server port; defaults to <code>80</code>.</p> <code>80</code> <code>path</code> <code>str</code> <p>Resource path, for example <code>\"/api\"</code> or <code>\"/\"</code>.</p> <code>'/'</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Optional additional request headers.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Response body decoded as UTF-8 (errors replaced).</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>When the socket cannot connect.</p> <code>error</code> <p>For lower-level network errors.</p> Example <p>body = http_get(\"example.com\", 80, \"/\") print(body)</p>"},{"location":"http/reference/#kn_sock.http.http_post","title":"<code>http_post(host: str, port: int = 80, path: str = '/', data: str = '', headers: Optional[Dict[str, str]] = None) -&gt; str</code>","text":"<p>Send a synchronous HTTP POST request with a string payload.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Server hostname or IP address.</p> required <code>port</code> <code>int</code> <p>Server port; defaults to <code>80</code>.</p> <code>80</code> <code>path</code> <code>str</code> <p>Resource path.</p> <code>'/'</code> <code>data</code> <code>str</code> <p>Request body as a string.</p> <code>''</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Optional additional request headers.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Response body decoded as UTF-8 (errors replaced).</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>When the socket cannot connect.</p> <code>error</code> <p>For lower-level network errors.</p> Example <p>body = http_post(\"localhost\", 8000, \"/\", \"name=knsock\") assert \"200 OK\" in body</p>"},{"location":"http/reference/#https-client-apis","title":"HTTPS Client APIs","text":""},{"location":"http/reference/#kn_sock.http.https_get","title":"<code>https_get(host: str, port: int = 443, path: str = '/', headers: Optional[Dict[str, str]] = None, cafile: Optional[str] = None) -&gt; str</code>","text":"<p>Send a synchronous HTTPS GET request.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Server hostname.</p> required <code>port</code> <code>int</code> <p>Server port; defaults to <code>443</code>.</p> <code>443</code> <code>path</code> <code>str</code> <p>Resource path.</p> <code>'/'</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Optional additional request headers.</p> <code>None</code> <code>cafile</code> <code>Optional[str]</code> <p>Path to a CA bundle file to verify the server certificate.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Response body decoded as UTF-8 (errors replaced).</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>When the socket cannot connect.</p> <code>SSLError</code> <p>For TLS handshake problems.</p> Example <p>body = https_get(\"api.github.com\", 443, \"/\") print(body)</p>"},{"location":"http/reference/#kn_sock.http.https_post","title":"<code>https_post(host: str, port: int = 443, path: str = '/', data: str = '', headers: Optional[Dict[str, str]] = None, cafile: Optional[str] = None) -&gt; str</code>","text":"<p>Send a synchronous HTTPS POST request with a string payload.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Server hostname.</p> required <code>port</code> <code>int</code> <p>Server port; defaults to <code>443</code>.</p> <code>443</code> <code>path</code> <code>str</code> <p>Resource path.</p> <code>'/'</code> <code>data</code> <code>str</code> <p>Request body as a string.</p> <code>''</code> <code>headers</code> <code>Optional[Dict[str, str]]</code> <p>Optional additional request headers.</p> <code>None</code> <code>cafile</code> <code>Optional[str]</code> <p>Path to a CA bundle file to verify the server certificate.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>Response body decoded as UTF-8 (errors replaced).</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>When the socket cannot connect.</p> <code>SSLError</code> <p>For TLS handshake problems.</p> Example <p>body = https_post(\"example.com\", 443, \"/submit\", \"payload\") print(body)</p>"},{"location":"http/reference/#http-server","title":"HTTP Server","text":""},{"location":"http/reference/#kn_sock.http.start_http_server","title":"<code>start_http_server(host: str, port: int, static_dir: Optional[str] = None, routes: Optional[Dict[str, Callable]] = None, shutdown_event: Optional[threading.Event] = None)</code>","text":"<p>Start a blocking, single-thread-per-client HTTP server.</p> <p>The server handles three simple cases:</p> <ol> <li>If routes defines a handler for <code>(method, path)</code>, that handler runs.    The handler must send the full HTTP response on the passed socket.</li> <li>If static_dir is set, any other path maps to <code>static_dir/&lt;path&gt;</code>.    Missing files return 404.</li> <li>Any unmatched request returns 404.</li> </ol> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Bind address (for example <code>\"0.0.0.0\"</code>).</p> required <code>port</code> <code>int</code> <p>Bind port.</p> required <code>static_dir</code> <code>Optional[str]</code> <p>Optional directory to serve static files from.</p> <code>None</code> <code>routes</code> <code>Optional[Dict[str, Callable]]</code> <p>Optional mapping of <code>(method, path)</code> tuples to handler functions.  A handler receives <code>(request_dict, client_socket)</code>.</p> <code>None</code> <code>shutdown_event</code> <code>Optional[Event]</code> <p>Optional :class:<code>threading.Event</code> that, when set, prompts the server loop to exit cleanly.</p> <code>None</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If the socket fails to bind (e.g., port already in use).</p> <code>ValueError</code> <p>If invalid handler arguments or routes are passed.</p> <code>RuntimeError</code> <p>If a threading error occurs when starting the server.</p> Example <pre><code>from kn_sock.http import start_http_server\n\ndef ping(req, sock):\n    sock.sendall(b\"HTTP/1.1 200 OK\\r\\nContent-Length: 4\\r\\n\\r\\npong\")\n\nstart_http_server(\n    host=\"0.0.0.0\",\n    port=8080,\n    routes={(\"GET\", \"/ping\"): ping}\n)\n</code></pre>"},{"location":"http/testing/","title":"Testing &amp; Troubleshooting","text":""},{"location":"http/testing/#known-issues-troubleshooting","title":"Known\u202fIssues &amp; Troubleshooting","text":"Issue Symptom/Output Solution Port already in use <code>[Errno 98] Address already in use</code> Use a different port or kill other process No response/404 <code>404 Not found</code> or empty output Check route/path; static only by default HTTPS errors SSL certificate errors Use valid/test certs or skip verification Hostname not found <code>[Errno -2] Name or service not known</code> Use container IP for Docker setups"},{"location":"http/testing/#manual-test","title":"Manual\u202fTest","text":"<p>Start the server <pre><code>docker-compose run --rm knsock run-http-server 8000\n</code></pre></p> <p>In another terminal <pre><code>docker-compose run --rm knsock http-get &lt;server-ip&gt; 8000 /\n# Example:\ndocker-compose run --rm knsock http-get 172.18.0.2 8000 /\n</code></pre></p> <p>Verify that the response is 200\u202fOK and that the expected body appears.</p>"},{"location":"http/testing/#related-topics","title":"Related Topics","text":"<ul> <li>CLI commands</li> <li>Python API</li> <li>Reference</li> </ul>"},{"location":"tcp/","title":"TCP Utilities","text":"<p><code>kn-sock</code> provides both CLI commands and a Python API for building, testing, and automating TCP server\u2013client communication. You can use it for basic network testing, multi-client echo servers, encrypted TLS communication, and connection pooling.</p> <p>Choose the interface that suits your workflow:</p> <ul> <li>Use the CLI to run quick tests or scripts in Docker.</li> <li>Use the Python API to integrate TCP utilities into your applications.</li> </ul>"},{"location":"tcp/#function-index","title":"Function Index","text":"Function/Class Description start_tcp_server Basic synchronous TCP server for single-connection, blocking I/O. start_threaded_tcp_server Multithreaded TCP server that spawns a thread per client. send_tcp_message Sync TCP client that sends a UTF-8 message and logs the response. send_tcp_bytes Sync TCP client for sending raw bytes. start_async_tcp_server Async TCP server using <code>asyncio</code>. send_tcp_message_async Async TCP client for sending messages without blocking. TCPConnectionPool Thread-safe pool for managing reusable TCP (and SSL) connections. start_ssl_tcp_server Synchronous TCP server with TLS/mTLS support. send_ssl_tcp_message TLS-enabled sync client for secure message exchange. start_async_ssl_tcp_server Async TLS server using <code>asyncio</code>. send_ssl_tcp_message_async Async TLS client using non-blocking secure sockets."},{"location":"tcp/#related-topics","title":"Related Topics","text":"<ul> <li>Using the CLI</li> <li>Using the Python API</li> <li>API Reference</li> <li>Testing &amp; Troubleshooting</li> </ul>"},{"location":"tcp/cli/","title":"TCP: Using the CLI","text":"<p>The <code>knsock</code> command-line interface allows you to start TCP servers and send messages over TCP directly from the shell. It's ideal for testing or scripting quick network interactions without writing Python code.</p>"},{"location":"tcp/cli/#run-a-tcp-echo-server","title":"Run a TCP Echo Server","text":"<p>Start a server that echoes back any received messages.</p>"},{"location":"tcp/cli/#command","title":"Command","text":"<pre><code>knsock run-tcp-server &lt;port&gt;\n</code></pre> <p>Or using Docker:</p> <pre><code>docker-compose run --rm knsock run-tcp-server 8080\n</code></pre>"},{"location":"tcp/cli/#example-output","title":"Example Output","text":"<pre><code>[TCP] Server listening on 0.0.0.0:8080\n</code></pre>"},{"location":"tcp/cli/#send-a-tcp-message","title":"Send a TCP Message","text":"<p>Connect to a TCP server and send a UTF-8 string message.</p>"},{"location":"tcp/cli/#command_1","title":"Command","text":"<pre><code>knsock send-tcp &lt;host&gt; &lt;port&gt; &lt;message&gt;\n</code></pre> <p>Or using Docker:</p> <pre><code>docker-compose run --rm knsock send-tcp &lt;host&gt; &lt;port&gt; &lt;message&gt;\n</code></pre>"},{"location":"tcp/cli/#example","title":"Example","text":"<pre><code>docker-compose run --rm knsock send-tcp 172.18.0.2 8080 \"Hello TCP\"\n</code></pre>"},{"location":"tcp/cli/#example-output_1","title":"Example Output","text":"<pre><code>[TCP] Server response: Echo: Hello TCP\n</code></pre>"},{"location":"tcp/cli/#cli-options","title":"CLI Options","text":"Argument Description <code>&lt;port&gt;</code> Port to bind for the server or connect to <code>&lt;host&gt;</code> IP or hostname of the TCP server (client only) <code>&lt;message&gt;</code> Text to send to the server (client only)"},{"location":"tcp/cli/#getting-the-server-ip-docker","title":"Getting the Server IP (Docker)","text":"<p>If you're running the TCP server in a Docker container, you\u2019ll need its internal IP to connect from the client.</p>"},{"location":"tcp/cli/#step-1-list-running-containers","title":"Step 1: List Running Containers","text":"<pre><code>docker ps\n</code></pre> <p>Look for the NAMES column, e.g.:</p> <pre><code>CONTAINER ID   IMAGE         ...   NAMES\nc8abcb1a321d   knsock_knsock ...  knsock_knsock_run-tcp-server_1\n</code></pre>"},{"location":"tcp/cli/#step-2-get-the-containers-ip-address","title":"Step 2: Get the Container's IP Address","text":"<pre><code>docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' &lt;container_name_or_id&gt;\n</code></pre> <p>Use this IP as the <code>&lt;host&gt;</code> value when calling <code>send-tcp</code>.</p>"},{"location":"tcp/cli/#troubleshooting","title":"Troubleshooting","text":"Issue Error or Output Suggested Fix Port already in use <code>OSError: [Errno 98] Address in use</code> Choose a different port or stop the running server Connection refused <code>ConnectionRefusedError</code> Ensure the server is running and accepting connections Hostname not found <code>[Errno -2] Name or service not known</code> Use the container IP instead of the name"},{"location":"tcp/cli/#related-topics","title":"Related Topics","text":"<ul> <li>Using the Python API</li> <li>Full TCP Function Reference</li> <li>Testing Instructions</li> </ul>"},{"location":"tcp/python-api/","title":"Using the Python API","text":"<p>The <code>kn_sock</code> Python API allows you to build, test, and scale TCP servers and clients directly in your applications. Use it to create synchronous or asynchronous servers, send messages, or manage secure connections.</p>"},{"location":"tcp/python-api/#api-quickstart","title":"API Quickstart","text":"<p>These examples help you get started with the most common use cases.</p>"},{"location":"tcp/python-api/#start-a-simple-tcp-echo-server","title":"Start a Simple TCP Echo Server","text":"<pre><code>from kn_sock import start_tcp_server\n\ndef echo_handler(data, addr, conn):\n    conn.sendall(b\"Echo: \" + data)\n\nstart_tcp_server(8080, echo_handler)\n</code></pre>"},{"location":"tcp/python-api/#send-a-tcp-message","title":"Send a TCP Message","text":"<pre><code>from kn_sock import send_tcp_message\n\nsend_tcp_message('127.0.0.1', 8080, \"Hello TCP\")\n</code></pre>"},{"location":"tcp/python-api/#send-raw-bytes","title":"Send Raw Bytes","text":"<pre><code>from kn_sock import send_tcp_bytes\n\nsend_tcp_bytes('127.0.0.1', 8080, b\"\\x00\\x01\\x02\")\n</code></pre>"},{"location":"tcp/python-api/#start-an-async-tcp-server","title":"Start an Async TCP Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_async_tcp_server\n\nasync def echo_handler(reader, writer):\n    data = await reader.read(1024)\n    writer.write(b\"Echo: \" + data)\n    await writer.drain()\n    writer.close()\n\nasyncio.run(start_async_tcp_server(8081, echo_handler))\n</code></pre>"},{"location":"tcp/python-api/#send-a-secure-message-tls","title":"Send a Secure Message (TLS)","text":"<pre><code>from kn_sock import send_ssl_tcp_message\n\nsend_ssl_tcp_message('127.0.0.1', 8443, \"Secure Hello\")\n</code></pre>"},{"location":"tcp/python-api/#example-server-client","title":"Example: Server + Client","text":"Server <pre><code>from kn_sock import start_tcp_server\n\ndef echo_handler(data, addr, conn):\n    print(f\"Received from {addr}: {data.decode()}\")\n    conn.sendall(b\"Echo: \" + data)\n\nstart_tcp_server(8080, echo_handler)\n</code></pre> Client <pre><code>from kn_sock import send_tcp_message\n\nsend_tcp_message('127.0.0.1', 8080, \"Hello TCP\")\n</code></pre>"},{"location":"tcp/python-api/#sample-output","title":"Sample Output","text":"<p>Server Terminal:</p> <pre><code>[TCP] Server listening on 0.0.0.0:8080\n[TCP][SERVER] Received from ('172.18.0.1', 49906): b'Hello TCP'\n</code></pre> <p>Client Terminal:</p> <pre><code>[TCP] Server response: Echo: Hello TCP\n</code></pre>"},{"location":"tcp/python-api/#async-client-example","title":"Async Client Example","text":"<pre><code>import asyncio\nfrom kn_sock import send_tcp_message_async\n\nasync def main():\n    await send_tcp_message_async('127.0.0.1', 8080, \"Async Hello\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"tcp/python-api/#when-to-use-sync-vs-async","title":"When to Use Sync vs Async","text":"Scenario Use Simple, single-threaded scripts Synchronous API Handling many simultaneous connections Asynchronous API with asyncio Performance under high I/O load Async server + client Secure, encrypted messaging SSL/TLS server and client functions"},{"location":"tcp/python-api/#related-topics","title":"Related Topics","text":"<ul> <li>Full Reference Documentation</li> <li>Run Manual Tests</li> <li>Use the CLI for quick testing</li> </ul>"},{"location":"tcp/reference/","title":"API Reference","text":"<p>This page documents all public classes and functions available in the <code>kn_sock.tcp</code> module. You can use these directly in your Python applications or scripts.</p>"},{"location":"tcp/reference/#tcp-server-apis","title":"TCP Server APIs","text":""},{"location":"tcp/reference/#synchronous-servers","title":"Synchronous Servers","text":""},{"location":"tcp/reference/#kn_sock.tcp.start_tcp_server","title":"<code>start_tcp_server(port: int, handler_func: Callable[[bytes, tuple, socket.socket], None], host: str = '0.0.0.0', shutdown_event: Optional[threading.Event] = None)</code>","text":"<p>Starts a synchronous TCP server (IPv4/IPv6 supported).</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle (data, addr, client_socket).</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6).</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, server will exit when event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket fails.</p> <code>error</code> <p>For general network errors.</p> Example <p>def echo_handler(data, addr, sock): ...     print(data) ...     sock.sendall(data) start_tcp_server(8080, echo_handler)</p>"},{"location":"tcp/reference/#kn_sock.tcp.start_threaded_tcp_server","title":"<code>start_threaded_tcp_server(port: int, handler_func: Callable[[bytes, tuple, socket.socket], None], host: str = '0.0.0.0', shutdown_event: Optional[threading.Event] = None)</code>","text":"<p>Starts a multithreaded TCP server (IPv4/IPv6 supported).</p> <p>This function listens for incoming TCP connections on the specified port, spawning a new thread for each client. The handler function is called for each message received from a client.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle incoming data. Signature: (data: bytes, addr: tuple, client_socket: socket.socket) -&gt; None</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>error</code> <p>For network-related errors.</p> Example <p>def echo_handler(data, addr, sock): ...     print(f\"From {addr}: {data}\") ...     sock.sendall(b\"Echo: \" + data) import threading shutdown = threading.Event() start_threaded_tcp_server(8080, echo_handler, shutdown_event=shutdown)</p>"},{"location":"tcp/reference/#asynchronous-servers","title":"Asynchronous Servers","text":""},{"location":"tcp/reference/#kn_sock.tcp.start_async_tcp_server","title":"<code>start_async_tcp_server(port: int, handler_func: Callable[[bytes, tuple, asyncio.StreamWriter], Awaitable[None]], host: str = '0.0.0.0', shutdown_event: Optional[asyncio.Event] = None)</code>  <code>async</code>","text":"<p>Starts an asynchronous TCP server (IPv4/IPv6 supported).</p> <p>Listens for incoming TCP connections on the specified port using asyncio, spawning a coroutine for each client. The handler function is called with received data, the client address, and the StreamWriter for responses. Supports graceful shutdown when a shutdown_event is set.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>Async function to handle incoming data. Signature: (data: bytes, addr: tuple, writer: asyncio.StreamWriter) -&gt; Awaitable[None]</p> required <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>CancelledError</code> <p>If the server task is cancelled.</p> Example <p>import asyncio async def echo_handler(data, addr, writer): ...     print(f\"Received from {addr}: {data.decode()}\") ...     writer.write(b\"Echo: \" + data) ...     await writer.drain() asyncio.run(start_async_tcp_server(8080, echo_handler))</p>"},{"location":"tcp/reference/#tcp-client-apis","title":"TCP Client APIs","text":""},{"location":"tcp/reference/#synchronous-clients","title":"Synchronous Clients","text":""},{"location":"tcp/reference/#kn_sock.tcp.send_tcp_message","title":"<code>send_tcp_message(host: str, port: int, message: str)</code>","text":"<p>Sends a message to a TCP server (IPv4/IPv6 supported) and logs the server's response.</p> <p>Opens a TCP connection to the specified host and port, sends the given message as UTF-8 bytes, and logs the server's response (if any) to the logger. This function does not return the server's response.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_tcp_message(\"localhost\", 8080, \"hello world\")</p>"},{"location":"tcp/reference/#kn_sock.tcp.send_tcp_bytes","title":"<code>send_tcp_bytes(host: str, port: int, data: bytes)</code>","text":"<p>Sends raw bytes to a TCP server and logs the response.</p> <p>Opens a TCP connection to the specified host and port, sends the given data as-is (no encoding), and logs the server's response (if any) as bytes. This function does not return the response.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>data</code> <code>bytes</code> <p>The data to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_tcp_bytes(\"127.0.0.1\", 8080, b\"ping\")</p>"},{"location":"tcp/reference/#asynchronous-clients","title":"Asynchronous Clients","text":""},{"location":"tcp/reference/#kn_sock.tcp.send_tcp_message_async","title":"<code>send_tcp_message_async(host: str, port: int, message: str)</code>  <code>async</code>","text":"<p>Sends a message to a TCP server asynchronously and returns the response.</p> <p>Opens an asynchronous TCP connection to the specified host and port, sends the given message as UTF-8 bytes, and awaits the server's response as a string. Returns None if no response is received.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The target host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The target port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>error</code> <p>For network-related errors.</p> Example <p>import asyncio response = asyncio.run(send_tcp_message_async(\"localhost\", 8080, \"hello async\")) print(response) Echo: hello async</p>"},{"location":"tcp/reference/#connection-pooling","title":"Connection Pooling","text":""},{"location":"tcp/reference/#kn_sock.tcp.TCPConnectionPool","title":"<code>TCPConnectionPool</code>","text":"<p>Thread-safe TCP/SSL connection pool for efficient reuse of socket connections.</p> <p>Manages a pool of TCP or SSL connections to a given host and port, allowing multiple threads to acquire and release connections as needed. The pool automatically closes idle connections after a configurable timeout.</p> <p>Typical usage:</p> <pre><code>&gt;&gt;&gt; pool = TCPConnectionPool(\"localhost\", 8080, max_size=5, idle_timeout=30)\n&gt;&gt;&gt; with pool.connection() as conn:\n...     conn.sendall(b\"ping\")\n...     response = conn.recv(1024)\n&gt;&gt;&gt; pool.closeall()\n</code></pre> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>max_size</code> <code>int</code> <p>Maximum number of concurrent connections. Defaults to 5.</p> <code>5</code> <code>idle_timeout</code> <code>int</code> <p>Seconds before idle connections are closed. Defaults to 30.</p> <code>30</code> <code>ssl</code> <code>bool</code> <p>Whether to use SSL/TLS for connections. Defaults to False.</p> <code>False</code> <code>cafile</code> <code>str</code> <p>Path to CA certificate for SSL/TLS verification.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to client certificate for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to client private key for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Methods:</p> Name Description <code>connection</code> <p>Acquire a connection from the pool as a context manager.</p> <code>closeall</code> <p>Close all connections and clear the pool.</p> Notes <ul> <li>Connections are managed in a thread-safe manner using an internal lock.</li> <li>Idle connections are closed and removed from the pool after <code>idle_timeout</code> seconds.</li> <li>When <code>max_size</code> is reached, additional requests block until a connection is released.</li> </ul> Example <p>pool = TCPConnectionPool(\"localhost\", 8080, ssl=True, cafile=\"ca.pem\") with pool.connection() as conn: ...     conn.sendall(b\"hello\") ...     print(conn.recv(1024)) pool.closeall()</p>"},{"location":"tcp/reference/#ssltls-servers","title":"SSL/TLS Servers","text":""},{"location":"tcp/reference/#synchronous","title":"Synchronous","text":""},{"location":"tcp/reference/#kn_sock.tcp.start_ssl_tcp_server","title":"<code>start_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event: Optional[threading.Event] = None)</code>","text":"<p>Starts a synchronous SSL/TLS TCP server with optional client certificate verification.</p> <p>Listens for incoming SSL/TLS connections on the specified port. For each client connection, wraps the socket with SSL/TLS, then invokes the handler function with the received data, client address, and SSL socket. Supports IPv4 and IPv6.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>callable</code> <p>Function to handle incoming data. Signature: (data: bytes, addr: tuple, ssl_sock: ssl.SSLSocket) -&gt; None</p> required <code>certfile</code> <code>str</code> <p>Path to the server certificate file in PEM format.</p> required <code>keyfile</code> <code>str</code> <p>Path to the server private key file in PEM format.</p> required <code>cafile</code> <code>str</code> <p>Path to CA certificate for verifying client certificates.</p> <code>None</code> <code>require_client_cert</code> <code>bool</code> <p>Whether to require client certificates for mutual TLS. Defaults to False.</p> <code>False</code> <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>SSLError</code> <p>For SSL/TLS handshake or certificate errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>def echo_handler(data, addr, ssl_sock): ...     print(f\"Received from {addr}: {data}\") ...     ssl_sock.sendall(b\"Echo: \" + data) start_ssl_tcp_server( ...     port=8443, ...     handler_func=echo_handler, ...     certfile=\"server.pem\", ...     keyfile=\"server-key.pem\" ... )</p>"},{"location":"tcp/reference/#asynchronous","title":"Asynchronous","text":""},{"location":"tcp/reference/#kn_sock.tcp.start_async_ssl_tcp_server","title":"<code>start_async_ssl_tcp_server(port, handler_func, certfile, keyfile, cafile=None, require_client_cert=False, host='0.0.0.0', shutdown_event: Optional[asyncio.Event] = None)</code>  <code>async</code>","text":"<p>Starts an asynchronous SSL/TLS TCP server with optional client certificate verification.</p> <p>Listens for incoming SSL/TLS connections using asyncio on the specified port. For each client, wraps the connection with SSL/TLS and invokes the provided async handler function with the received data, client address, and StreamWriter. Supports IPv4 and IPv6, as well as graceful shutdown.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>Async function to handle incoming data. Signature: (data: bytes, addr: tuple, writer: asyncio.StreamWriter) -&gt; Awaitable[None]</p> required <code>certfile</code> <code>str</code> <p>Path to the server certificate file in PEM format.</p> required <code>keyfile</code> <code>str</code> <p>Path to the server private key file in PEM format.</p> required <code>cafile</code> <code>str</code> <p>Path to CA certificate for verifying client certificates.</p> <code>None</code> <code>require_client_cert</code> <code>bool</code> <p>Whether to require client certificates for mutual TLS. Defaults to False.</p> <code>False</code> <code>host</code> <code>str</code> <p>Host to bind (IPv4 or IPv6). Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit gracefully when this event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the port is unavailable or socket operations fail.</p> <code>SSLError</code> <p>For SSL/TLS handshake or certificate errors.</p> <code>CancelledError</code> <p>If the server task is cancelled.</p> Example <p>import asyncio async def echo_handler(data, addr, writer): ...     print(f\"Received from {addr}: {data.decode()}\") ...     writer.write(b\"Echo: \" + data) ...     await writer.drain() asyncio.run(start_async_ssl_tcp_server( ...     port=8443, ...     handler_func=echo_handler, ...     certfile=\"server.pem\", ...     keyfile=\"server-key.pem\" ... ))</p>"},{"location":"tcp/reference/#ssltls-clients","title":"SSL/TLS Clients","text":""},{"location":"tcp/reference/#synchronous_1","title":"Synchronous","text":""},{"location":"tcp/reference/#kn_sock.tcp.send_ssl_tcp_message","title":"<code>send_ssl_tcp_message(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code>","text":"<p>Sends a message to an SSL/TLS TCP server and returns the response.</p> <p>Opens a secure SSL/TLS connection to the specified host and port, sends the given message as UTF-8 bytes, and returns the server's response as a string if one is received. Supports server verification and mutual TLS.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <code>cafile</code> <code>str</code> <p>Path to a CA certificate file for verifying the server.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to the client certificate file for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to the client private key file for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>SSLError</code> <p>For SSL/TLS handshake or verification errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>send_ssl_tcp_message( ...     host=\"localhost\", ...     port=8443, ...     message=\"secure hello\", ...     cafile=\"ca.pem\" ... ) 'Echo: secure hello'</p>"},{"location":"tcp/reference/#asynchronous_1","title":"Asynchronous","text":""},{"location":"tcp/reference/#kn_sock.tcp.send_ssl_tcp_message_async","title":"<code>send_ssl_tcp_message_async(host, port, message, cafile=None, certfile=None, keyfile=None, verify=True)</code>  <code>async</code>","text":"<p>Sends a message to an SSL/TLS TCP server asynchronously and returns the response.</p> <p>Opens an asynchronous SSL/TLS connection to the specified host and port, sends the given message as UTF-8 bytes, and awaits the server's response as a string. Supports server verification and mutual TLS authentication.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>The server host address (IPv4, IPv6, or hostname).</p> required <code>port</code> <code>int</code> <p>The server port number.</p> required <code>message</code> <code>str</code> <p>The message to send.</p> required <code>cafile</code> <code>str</code> <p>Path to a CA certificate file for verifying the server.</p> <code>None</code> <code>certfile</code> <code>str</code> <p>Path to the client certificate file for mutual TLS.</p> <code>None</code> <code>keyfile</code> <code>str</code> <p>Path to the client private key file for mutual TLS.</p> <code>None</code> <code>verify</code> <code>bool</code> <p>Whether to verify the server certificate. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>Optional[str]: The response from the server as a UTF-8 string, or None if no response is received.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If unable to connect to the server.</p> <code>SSLError</code> <p>For SSL/TLS handshake or verification errors.</p> <code>error</code> <p>For network-related errors.</p> Example <p>import asyncio response = asyncio.run( ...     send_ssl_tcp_message_async( ...         host=\"localhost\", ...         port=8443, ...         message=\"secure async hello\", ...         cafile=\"ca.pem\" ...     ) ... ) print(response) Echo: secure async hello</p>"},{"location":"tcp/testing/","title":"Testing","text":"<p>This page provides manual test instructions to verify your TCP setup using either the CLI or Python API. These tests confirm that both the server and client components are functioning correctly and communicating over the network.</p>"},{"location":"tcp/testing/#test-1-using-docker-cli","title":"Test 1: Using Docker CLI","text":""},{"location":"tcp/testing/#step-1-start-a-tcp-echo-server","title":"Step 1: Start a TCP Echo Server","text":"<p>In one terminal window:</p> <pre><code>docker-compose run --rm knsock run-tcp-server 8080\n</code></pre>"},{"location":"tcp/testing/#expected-output","title":"Expected output:","text":"<pre><code>[TCP] Server listening on 0.0.0.0:8080\n</code></pre>"},{"location":"tcp/testing/#step-2-send-a-message-from-a-client","title":"Step 2: Send a Message from a Client","text":"<p>In another terminal window:</p> <pre><code># Replace &lt;server-ip&gt; with the container's IP address\ndocker-compose run --rm knsock send-tcp &lt;server-ip&gt; 8080 \"Hello TCP\"\n</code></pre>"},{"location":"tcp/testing/#example","title":"Example:","text":"<pre><code>docker-compose run --rm knsock send-tcp 172.18.0.2 8080 \"Hello TCP\"\n</code></pre>"},{"location":"tcp/testing/#expected-output_1","title":"Expected output:","text":"<pre><code>[TCP] Server response: Echo: Hello TCP\n</code></pre>"},{"location":"tcp/testing/#how-to-find-the-container-ip","title":"How to Find the Container IP","text":"<p>If you do not know the <code>&lt;server-ip&gt;</code>, run:</p> <pre><code>docker ps\n</code></pre> <p>Then inspect the server container:</p> <pre><code>docker inspect -f '{{range.NetworkSettings.Networks}}{{.IPAddress}}{{end}}' &lt;container_name_or_id&gt;\n</code></pre> <p>Use the resulting IP address as the host for your client command.</p>"},{"location":"tcp/testing/#test-2-using-python","title":"Test 2: Using Python","text":""},{"location":"tcp/testing/#start-the-server-in-one-terminal","title":"Start the server in one terminal:","text":"<pre><code># server.py\nfrom kn_sock import start_tcp_server\n\ndef echo_handler(data, addr, conn):\n    print(f\"Received from {addr}: {data.decode()}\")\n    conn.sendall(b\"Echo: \" + data)\n\nstart_tcp_server(8080, echo_handler)\n</code></pre>"},{"location":"tcp/testing/#then-run-the-client-from-another-terminal","title":"Then run the client from another terminal:","text":"<pre><code># client.py\nfrom kn_sock import send_tcp_message\n\nsend_tcp_message(\"127.0.0.1\", 8080, \"Hello TCP\")\n</code></pre>"},{"location":"tcp/testing/#expected-output-in-the-server-terminal","title":"Expected output in the server terminal:","text":"<pre><code>[TCP] Server listening on 0.0.0.0:8080\n[TCP][SERVER] Received from ('127.0.0.1', 50000): b'Hello TCP'\n</code></pre>"},{"location":"tcp/testing/#expected-output-in-the-client-terminal","title":"Expected output in the client terminal:","text":"<pre><code>[TCP] Server response: Echo: Hello TCP\n</code></pre>"},{"location":"tcp/testing/#common-errors","title":"Common Errors","text":"Error Message or Symptom Fix Port already in use <code>OSError: [Errno 98] Address in use</code> Use a different port or stop the conflicting process Server not responding <code>ConnectionRefusedError</code> Verify that the server is running and reachable DNS resolution failed (Docker) <code>Name or service not known</code> Use the container IP address instead of the container name No response or empty output No logs or messages received Confirm that port numbers match and the server is properly configured"},{"location":"tcp/testing/#optional-add-test-script","title":"Optional: Add Test Script","text":"<p>You can create a basic test script to automate verification:</p> <pre><code>python test_tcp_connection.py\n</code></pre>"},{"location":"tcp/testing/#example-test_tcp_connectionpy","title":"Example test_tcp_connection.py:","text":"<pre><code>from kn_sock import send_tcp_message\n\ntry:\n    send_tcp_message(\"127.0.0.1\", 8080, \"Ping\")\n    print(\"TCP test passed\")\nexcept Exception as e:\n    print(f\"TCP test failed: {e}\")\n</code></pre>"},{"location":"tcp/testing/#related-topics","title":"Related Topics","text":"<ul> <li>Using the CLI</li> <li>Using the Python API</li> <li>API Reference</li> </ul>"},{"location":"udp/","title":"UDP Utilities","text":"<p><code>kn-sock</code> provides a set of UDP tools for sending and receiving datagrams over IPv4 or IPv6, with support for both synchronous and asynchronous workflows. It also includes utilities for multicast communication.</p> <p>Use these tools to build, test, and automate UDP-based communication in your scripts or applications.</p>"},{"location":"udp/#function-index","title":"Function Index","text":"Function/Class Description start_udp_server Starts a basic synchronous UDP server with graceful shutdown support. send_udp_message Sends a UTF-8 message to a UDP server. start_udp_server_async Starts an asynchronous UDP server using <code>asyncio</code>. send_udp_message_async Sends a message to a UDP server asynchronously. start_udp_multicast_server Starts a server that listens for multicast messages on a group and port. send_udp_multicast Sends a multicast message to a specific group and port."},{"location":"udp/#when-to-use-udp","title":"When to Use UDP","text":"<ul> <li>Low-latency or broadcast-style communication</li> <li>Fire-and-forget messages (no connection state)</li> <li>Multicast discovery or distributed coordination</li> <li>Non-blocking async I/O with high throughput</li> </ul> <p>For reliable or ordered delivery, consider using TCP Utilities.</p>"},{"location":"udp/#related-topics","title":"Related Topics","text":"<ul> <li>Using the CLI</li> <li>Using the Python API</li> <li>API Reference</li> <li>Testing &amp; Troubleshooting</li> </ul>"},{"location":"udp/cli/","title":"UDP: Using the CLI","text":"<p>The <code>knsock</code> command\u2011line interface now includes a set of synchronous UDP commands for rapid testing and lightweight messaging.</p> <p>All commands run inside the same Typer\u2011based CLI you use for TCP.</p> <p>Note</p> <p>These commands are synchronous. Asynchronous UDP helpers (e.g., <code>start_udp_server_async</code>) are available only in the Python API.</p>"},{"location":"udp/cli/#run-a-udp-echo-server","title":"Run a UDP Echo Server","text":"<p>Starts a UDP echo server that listens for datagrams and sends each message back to the sender.</p> Command Description <code>knsock udp run-udp-server &lt;port&gt;</code> Start a UDP echo server"},{"location":"udp/cli/#example","title":"Example","text":"<pre><code># Using pip\u2011installed knsock\nknsock udp run-udp-server 8081\n\n# Or inside Docker\ndocker-compose run --rm knsock knsock udp run-udp-server 8081\n</code></pre> <p>Expected output:</p> <pre><code>[UDP][SYNC] Server listening on 0.0.0.0:8081\n</code></pre>"},{"location":"udp/cli/#send-a-udp-message","title":"Send a UDP Message","text":"<p>Sends a UTF\u20118 datagram to a running UDP server.</p> Command Description <code>knsock udp send-udp &lt;host&gt; &lt;port&gt; &lt;msg&gt;</code> Send a UDP datagram"},{"location":"udp/cli/#example_1","title":"Example","text":"<pre><code>knsock udp send-udp 127.0.0.1 8081 \"Hello UDP\"\n</code></pre> <p>Expected output:</p> <pre><code>[UDP][SYNC] Sent to 127.0.0.1:8081\n</code></pre>"},{"location":"udp/cli/#run-a-udp-multicast-server","title":"Run a UDP Multicast Server","text":"<p>Listens for multicast datagrams on a group and port, then echoes each message back.</p> Command Description <code>knsock udp run-udp-multicast-server &lt;group&gt; &lt;port&gt;</code> Start a multicast listener"},{"location":"udp/cli/#example_2","title":"Example","text":"<pre><code>knsock udp run-udp-multicast-server 224.0.0.1 9000\n</code></pre> <p>Expected output:</p> <pre><code>[UDP][MULTICAST] Listening on group 224.0.0.1:9000\n</code></pre>"},{"location":"udp/cli/#send-a-multicast-message","title":"Send a Multicast Message","text":"<p>Sends a multicast datagram to a group and port.</p> Command Description <code>knsock udp send-udp-multicast &lt;group&gt; &lt;port&gt; &lt;msg&gt; [--ttl &lt;n&gt;]</code> Send a multicast datagram"},{"location":"udp/cli/#example_3","title":"Example","text":"<pre><code>knsock udp send-udp-multicast 224.0.0.1 9000 \"Multicast Hello\"\n</code></pre> <p>Expected output:</p> <pre><code>[UDP][SYNC] Sent to 224.0.0.1:9000\n</code></pre>"},{"location":"udp/cli/#options","title":"Options","text":"Option / Argument Description <code>&lt;port&gt;</code> Port for the server or destination port for the client <code>&lt;host&gt;</code> Destination IP or hostname for send-udp <code>&lt;message&gt;</code> UTF\u20118 message to send <code>&lt;group&gt;</code> Multicast group IP (e.g.,\u202f224.0.0.1) <code>--host</code> Host/IP to bind the server (default 0.0.0.0) <code>--listen-ip</code> Local interface for multicast server (default 0.0.0.0) <code>--ttl</code> Multicast TTL (default 1)"},{"location":"udp/cli/#cli-troubleshooting","title":"CLI Troubleshooting","text":"Issue / Error Likely Cause Suggested Fix Command not found CLI not installed or PATH issue Confirm knsock is installed and PATH is set Argument parsing failed Wrong order or missing args Check command syntax and required arguments OSError: [Errno 98] Address in use Port already in use Stop other server or choose another port Permission denied Insufficient privileges Use sudo (Linux) or run as admin (Windows) <p>For UDP protocol/network issues, see Testing &amp; Troubleshooting.</p>"},{"location":"udp/cli/#quick-cli-test","title":"Quick CLI Test","text":"<p>Open two terminals:</p> <p>Start the server <pre><code>docker-compose run --rm knsock udp run-udp-server 8081\n</code></pre></p> <p>Send a message</p> <pre><code>docker-compose run --rm knsock udp send-udp 127.0.0.1 8081 \"Hello UDP\"\n</code></pre> <p>Expected output</p> <p>Server</p> <pre><code>[UDP][SYNC] Listening on 0.0.0.0:8081\n[UDP][SYNC] Received from ('&lt;client-ip&gt;'): Hello UDP\n</code></pre> <p>Client</p> <pre><code>[UDP][SYNC] Sent to 127.0.0.1:8081\n</code></pre> <p>If it fails</p> <ul> <li>Verify you used the correct IP and port</li> <li>Check that both processes share the same Docker network (or use 127.0.0.1 outside Docker)</li> <li>Confirm no firewall is blocking UDP on 8081</li> </ul>"},{"location":"udp/cli/#related-topics","title":"Related Topics","text":"<ul> <li>Using the Python API</li> <li>API Reference</li> <li>Testing &amp; Troubleshooting</li> </ul>"},{"location":"udp/python-api/","title":"Using the Python API","text":"<p>The <code>kn_sock.udp</code> module provides a set of synchronous, asynchronous, and multicast utilities for working with UDP sockets. You can use these to send and receive datagrams, build non-blocking event-driven applications, or broadcast messages across a network.</p> <p>This page offers code examples for quick usage and integration.</p>"},{"location":"udp/python-api/#udp-quickstart","title":"UDP Quickstart","text":"<p>These examples cover the most common use cases.</p>"},{"location":"udp/python-api/#start-a-udp-echo-server-synchronous","title":"Start a UDP Echo Server (Synchronous)","text":"<pre><code>from kn_sock import start_udp_server\n\ndef echo_handler(data, addr, sock):\n    print(f\"Received from {addr}: {data.decode()}\")\n    sock.sendto(data, addr)\n\nstart_udp_server(8081, echo_handler)\n</code></pre>"},{"location":"udp/python-api/#send-a-udp-message-synchronous","title":"Send a UDP Message (Synchronous)","text":"<pre><code>from kn_sock import send_udp_message\n\nsend_udp_message(\"127.0.0.1\", 8081, \"Hello UDP\")\n</code></pre>"},{"location":"udp/python-api/#expected-output","title":"Expected output:","text":"<pre><code>[UDP][SYNC] Sent to 127.0.0.1:8081\n</code></pre>"},{"location":"udp/python-api/#start-a-udp-server-asynchronous","title":"Start a UDP Server (Asynchronous)","text":"<pre><code>import asyncio\nfrom kn_sock import start_udp_server_async\n\nasync def echo_handler(data, addr, transport):\n    print(f\"Received from {addr}: {data.decode()}\")\n    transport.sendto(data, addr)\n\nasyncio.run(start_udp_server_async(8082, echo_handler))\n</code></pre>"},{"location":"udp/python-api/#send-a-udp-message-asynchronous","title":"Send a UDP Message (Asynchronous)","text":"<pre><code>import asyncio\nfrom kn_sock import send_udp_message_async\n\nasync def main():\n    await send_udp_message_async(\"127.0.0.1\", 8082, \"Hello from async UDP\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"udp/python-api/#multicast-messaging","title":"Multicast Messaging","text":"<p>Use these functions to send and receive multicast packets in a local network.</p>"},{"location":"udp/python-api/#send-a-multicast-message","title":"Send a Multicast Message","text":"<pre><code>from kn_sock import send_udp_multicast\n\nsend_udp_multicast(\"224.0.0.1\", 9000, \"Broadcast message\")\n</code></pre>"},{"location":"udp/python-api/#start-a-multicast-server","title":"Start a Multicast Server","text":"<pre><code>from kn_sock import start_udp_multicast_server\n\ndef handler(data, addr, sock):\n    print(f\"[MULTICAST] {addr} says: {data.decode()}\")\n\nstart_udp_multicast_server(\"224.0.0.1\", 9000, handler)\n</code></pre>"},{"location":"udp/python-api/#note-multicast-reception-may-require-adjusting-firewall-settings-or-running-in-a-local-network","title":"Note: Multicast reception may require adjusting firewall settings or running in a local network.","text":""},{"location":"udp/python-api/#choosing-between-sync-and-async","title":"Choosing Between Sync and Async","text":"Use Case Recommended API Simple, low-frequency communication Synchronous (start_udp_server) Concurrent or event-driven applications Asynchronous (start_udp_server_async) Fire-and-forget messages send_udp_message or send_udp_message_async Broadcast/multicast messaging send_udp_multicast, start_udp_multicast_server"},{"location":"udp/python-api/#related-topics","title":"Related Topics","text":"<ul> <li>API Reference</li> <li>Testing &amp; Troubleshooting</li> </ul>"},{"location":"udp/reference/","title":"API Reference","text":"<p>This page documents all public functions available in the <code>kn_sock.udp</code> module, including support for synchronous, asynchronous, and multicast UDP communication.</p> <p>Each function below is part of the public API and can be used in your own projects.</p>"},{"location":"udp/reference/#udp-server-apis","title":"UDP Server APIs","text":""},{"location":"udp/reference/#synchronous","title":"Synchronous","text":""},{"location":"udp/reference/#kn_sock.udp.start_udp_server","title":"<code>start_udp_server(port: int, handler_func: Callable[[bytes, tuple, socket.socket], None], host: str = '0.0.0.0', shutdown_event=None)</code>","text":"<p>Starts a synchronous UDP server that listens for incoming datagrams and delegates them to a handler function.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>A function that handles incoming data.  Called as <code>handler_func(data, addr, socket)</code>.</p> required <code>host</code> <code>str</code> <p>Host/IP to bind to. Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will shut down gracefully when the event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If the socket fails to bind or encounters an error.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def echo_handler(data, addr, sock):\n...     print(f\"Received from {addr}: {data.decode()}\")\n...     sock.sendto(data, addr)\n&gt;&gt;&gt; import threading\n&gt;&gt;&gt; stop_event = threading.Event()\n&gt;&gt;&gt; start_udp_server(8081, echo_handler, shutdown_event=stop_event)\n</code></pre>"},{"location":"udp/reference/#asynchronous","title":"Asynchronous","text":""},{"location":"udp/reference/#kn_sock.udp.start_udp_server_async","title":"<code>start_udp_server_async(port: int, handler_func: Callable[[bytes, tuple, asyncio.DatagramTransport], Awaitable[None]], host: str = '0.0.0.0', shutdown_event=None)</code>  <code>async</code>","text":"<p>Starts an asynchronous UDP server using asyncio. Runs a handler for each incoming datagram.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Port to bind the server to.</p> required <code>handler_func</code> <code>Callable</code> <p>Async function called as <code>await handler_func(data, addr, transport)</code>.</p> required <code>host</code> <code>str</code> <p>Host/IP to bind to. Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will exit when the event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If socket setup fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; async def echo_handler(data, addr, transport):\n...     print(f\"Received from {addr}: {data.decode()}\")\n...     transport.sendto(data, addr)\n&gt;&gt;&gt; asyncio.run(start_udp_server_async(8082, echo_handler))\n</code></pre>"},{"location":"udp/reference/#udp-client-apis","title":"UDP Client APIs","text":""},{"location":"udp/reference/#synchronous_1","title":"Synchronous","text":""},{"location":"udp/reference/#kn_sock.udp.send_udp_message","title":"<code>send_udp_message(host: str, port: int, message: str)</code>","text":"<p>Sends a UTF-8 encoded message to a UDP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Target server hostname or IP address.</p> required <code>port</code> <code>int</code> <p>Destination port on the server.</p> required <code>message</code> <code>str</code> <p>Message to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If sending the datagram fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; send_udp_message(\"127.0.0.1\", 8081, \"Hello UDP\")\n</code></pre>"},{"location":"udp/reference/#asynchronous_1","title":"Asynchronous","text":""},{"location":"udp/reference/#kn_sock.udp.send_udp_message_async","title":"<code>send_udp_message_async(host: str, port: int, message: str)</code>  <code>async</code>","text":"<p>Sends a UTF-8 message asynchronously to a UDP server.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Target server hostname or IP address.</p> required <code>port</code> <code>int</code> <p>Destination port on the server.</p> required <code>message</code> <code>str</code> <p>Message to send.</p> required <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If sending the message fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; asyncio.run(send_udp_message_async(\"127.0.0.1\", 8082, \"Async Hello\"))\n</code></pre>"},{"location":"udp/reference/#multicast-apis","title":"Multicast APIs","text":""},{"location":"udp/reference/#send","title":"Send","text":""},{"location":"udp/reference/#kn_sock.udp.send_udp_multicast","title":"<code>send_udp_multicast(group: str, port: int, message: str, ttl: int = 1)</code>","text":"<p>Sends a multicast UDP message to a given group and port.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Multicast group IP (e.g., '224.0.0.1').</p> required <code>port</code> <code>int</code> <p>Multicast port number.</p> required <code>message</code> <code>str</code> <p>Message to send.</p> required <code>ttl</code> <code>int</code> <p>Time-to-live for multicast packets. Defaults to 1.</p> <code>1</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If socket configuration or send fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; send_udp_multicast(\"224.0.0.1\", 9000, \"Multicast Hello\")\n</code></pre>"},{"location":"udp/reference/#server","title":"Server","text":""},{"location":"udp/reference/#kn_sock.udp.start_udp_multicast_server","title":"<code>start_udp_multicast_server(group: str, port: int, handler_func: Callable[[bytes, tuple, socket.socket], None], listen_ip: str = '0.0.0.0', shutdown_event=None)</code>","text":"<p>Starts a UDP multicast server that listens for messages on a specified group and port.</p> <p>Parameters:</p> Name Type Description Default <code>group</code> <code>str</code> <p>Multicast group IP (e.g., '224.0.0.1').</p> required <code>port</code> <code>int</code> <p>Multicast port to listen on.</p> required <code>handler_func</code> <code>Callable</code> <p>Function called as <code>handler_func(data, addr, socket)</code> for each received message.</p> required <code>listen_ip</code> <code>str</code> <p>Local interface IP to bind to. Defaults to \"0.0.0.0\".</p> <code>'0.0.0.0'</code> <code>shutdown_event</code> <code>Event</code> <p>If provided, the server will shut down when the event is set.</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> <p>Raises:</p> Type Description <code>OSError</code> <p>If socket configuration or binding fails.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; def handler(data, addr, sock):\n...     print(f\"[MULTICAST] Received from {addr}: {data.decode()}\")\n&gt;&gt;&gt; import threading\n&gt;&gt;&gt; stop_event = threading.Event()\n&gt;&gt;&gt; start_udp_multicast_server(\"224.0.0.1\", 9000, handler, shutdown_event=stop_event)\n</code></pre>"},{"location":"udp/testing/","title":"Testing","text":"<p>This page provides instructions for testing the UDP utilities provided in <code>kn_sock.udp</code>, including synchronous, asynchronous, and multicast server-client communication.</p>"},{"location":"udp/testing/#test-1-synchronous-udp-echo-server","title":"Test 1: Synchronous UDP Echo Server","text":""},{"location":"udp/testing/#step-1-start-the-server","title":"Step 1: Start the Server","text":"<pre><code>from kn_sock import start_udp_server\n\ndef echo_handler(data, addr, sock):\n    print(f\"Received from {addr}: {data.decode()}\")\n    sock.sendto(data, addr)\n\nstart_udp_server(9001, echo_handler)\n</code></pre>"},{"location":"udp/testing/#step-2-send-a-message","title":"Step 2: Send a Message","text":"<p>In a second terminal or script:</p> <pre><code>from kn_sock import send_udp_message\n\nsend_udp_message(\"127.0.0.1\", 9001, \"Hello UDP\")\n</code></pre>"},{"location":"udp/testing/#expected-output-server-side","title":"Expected Output (Server Side):","text":"<pre><code>Received from ('127.0.0.1', &lt;port&gt;): Hello UDP\n</code></pre>"},{"location":"udp/testing/#test-2-asynchronous-udp-server","title":"Test 2: Asynchronous UDP Server","text":""},{"location":"udp/testing/#step-1-start-the-async-server","title":"Step 1: Start the Async Server","text":"<pre><code>import asyncio\nfrom kn_sock import start_udp_server_async\n\nasync def echo_handler(data, addr, transport):\n    print(f\"Received from {addr}: {data.decode()}\")\n    transport.sendto(data, addr)\n\nasyncio.run(start_udp_server_async(9002, echo_handler))\n</code></pre>"},{"location":"udp/testing/#step-2-send-a-message_1","title":"Step 2: Send a Message","text":"<pre><code>import asyncio\nfrom kn_sock import send_udp_message_async\n\nasync def main():\n    await send_udp_message_async(\"127.0.0.1\", 9002, \"Async Hello\")\n\nasyncio.run(main())\n</code></pre>"},{"location":"udp/testing/#expected-output-server-side_1","title":"Expected Output (Server Side):","text":"<pre><code>Received from ('127.0.0.1', &lt;port&gt;): Async Hello\n</code></pre>"},{"location":"udp/testing/#test-3-multicast","title":"Test 3: Multicast","text":""},{"location":"udp/testing/#step-1-start-the-multicast-listener","title":"Step 1: Start the Multicast Listener","text":"<pre><code>from kn_sock import start_udp_multicast_server\n\ndef handler(data, addr, sock):\n    print(f\"[MULTICAST] {addr} says: {data.decode()}\")\n\nstart_udp_multicast_server(\"224.0.0.1\", 9003, handler)\n</code></pre>"},{"location":"udp/testing/#step-2-send-a-multicast-message","title":"Step 2: Send a Multicast Message","text":"<pre><code>from kn_sock import send_udp_multicast\n\nsend_udp_multicast(\"224.0.0.1\", 9003, \"Multicast Hello\")\n</code></pre>"},{"location":"udp/testing/#expected-output","title":"Expected Output:","text":"<pre><code>[MULTICAST] ('&lt;sender_ip&gt;', &lt;port&gt;) says: Multicast Hello\n</code></pre>"},{"location":"udp/testing/#note-multicast-may-require-local-network-support-and-may-not-work-across-wi-fi-routers-or-cloud-hosted-containers-by-default","title":"Note: Multicast may require local network support and may not work across Wi-Fi routers or cloud-hosted containers by default.","text":""},{"location":"udp/testing/#common-issues","title":"Common Issues","text":"Error or Symptom Cause Solution No output or response Handler not sending response, wrong port Confirm ports match and response logic is correct OSError: [Errno 98] Address in use Port already occupied Use a different port or stop the existing server No multicast message received Network or OS doesn't support multicast Try binding to 0.0.0.0, check firewall/network OSError: [Errno 101] Network unreachable Multicast group/route not reachable Make sure you're on a LAN with multicast enabled <p>Having trouble with the CLI? See Using the CLI.</p>"},{"location":"udp/testing/#related-topics","title":"Related Topics","text":"<ul> <li>Using the Python API</li> <li>API Reference</li> </ul>"},{"location":"websocket/","title":"WebSocket Utilities","text":"<p><code>kn\u2011sock</code> adds a full\u2011duplex WebSocket layer on top of its HTTP helpers. Use it to build lightweight chat servers, real\u2011time dashboards, or any application that benefits from persistent, bidirectional messaging.</p> <p>Choose the interface that fits your workflow:</p> <ul> <li>CLI\u2003Run quick echo servers or send one\u2011off frames from the terminal.  </li> <li>Python API\u2003Embed servers or clients directly in your code (sync\u202for\u202fasync).</li> </ul>"},{"location":"websocket/#function-index","title":"Function\u00a0Index","text":"Function\u00a0/\u00a0Class Description start_websocket_server Thread\u2011per\u2011client synchronous WebSocket server connect_websocket Blocking client, returns <code>WebSocketConnection</code> WebSocketConnection Sync connection object (<code>send\u202f/\u202frecv\u202f/\u202fclose</code>) async_connect_websocket Asyncio client, returns <code>AsyncWebSocketConnection</code> AsyncWebSocketConnection Async connection object (<code>await send / recv / close</code>)"},{"location":"websocket/#when-to-use-websockets","title":"When\u00a0to\u00a0Use WebSockets","text":"<ul> <li>Real\u2011time dashboards, chat, or collaborative apps  </li> <li>Low\u2011latency, event\u2011driven messaging without HTTP request overhead  </li> <li>Client\u2011 and server\u2011initiated pushes over the same TCP socket  </li> </ul> <p>For simple request/response APIs, refer to HTTP Utilities.</p>"},{"location":"websocket/#quick-start","title":"Quick\u00a0Start","text":""},{"location":"websocket/#1-run-an-echo-server","title":"1\u202f\u00b7\u202fRun an echo server","text":"<pre><code>from kn_sock.websocket import start_websocket_server, WebSocketConnection\n\ndef echo(ws: WebSocketConnection):\n    while ws.open:\n        msg = ws.recv()\n        if msg:\n            ws.send(f\"Echo: {msg}\")\n\nstart_websocket_server(\"0.0.0.0\", 8765, echo)\n</code></pre>"},{"location":"websocket/#2-connect-sync","title":"2\u202f\u00b7\u202fConnect (sync)","text":"<pre><code>from kn_sock.websocket import connect_websocket\nws = connect_websocket(\"localhost\", 8765)\nws.send(\"hello\")\nprint(ws.recv())     # \u2192 Echo: hello\nws.close()\n</code></pre>"},{"location":"websocket/#3-connect-async","title":"3\u202f\u00b7\u202fConnect (async)","text":"<pre><code>import asyncio\nfrom kn_sock.websocket import async_connect_websocket\n\nasync def main():\n    ws = await async_connect_websocket(\"localhost\", 8765)\n    await ws.send(\"ping\")\n    print(await ws.recv())  # \u2192 Echo: ping\n    await ws.close()\n\nasyncio.run(main())\n</code></pre>"},{"location":"websocket/#common-options","title":"Common\u00a0Options","text":"Option Description host IP or hostname of the server port Port number (default\u00a08765 in examples) resource URL path (default /) headers Extra HTTP headers for the handshake"},{"location":"websocket/#known-issues-troubleshooting","title":"Known\u00a0Issues\u00a0&amp;\u00a0Troubleshooting","text":"Symptom / Error Likely Cause / Fix ConnectionError\u00a0\u2013 handshake failed Wrong port, proxy in the way, or bad Host header EOFError inside recv() Client closed socket mid\u2011frame UnicodeDecodeError on recv() Non\u2011UTF\u20118 payload received"},{"location":"websocket/#related-topics","title":"Related Topics","text":"<ul> <li>Using the CLI</li> <li>Using the Python API</li> <li>API Reference</li> <li>Testing\u00a0&amp;\u00a0Troubleshooting</li> </ul>"},{"location":"websocket/cli/","title":"Websocket: Using the CLI","text":"<p><code>kn\u2011sock</code> exposes basic WebSocket helpers under the <code>knsock websocket</code> namespace. They are thin wrappers around the Python API, ideal for smoke tests or shell scripts.</p> Command Description <code>knsock websocket run-server &lt;port&gt;</code> Start an echo server on <code>&lt;port&gt;</code> <code>knsock websocket send &lt;host&gt; &lt;port&gt; &lt;msg&gt;</code> Connect, send a text frame, print the reply"},{"location":"websocket/cli/#examples","title":"Examples","text":""},{"location":"websocket/cli/#start-an-echo-server-on-8765","title":"Start an echo server on\u00a08765","text":"<pre><code>docker-compose run --rm knsock websocket run-server 8765\n</code></pre> <p>Output:</p> <pre><code>[WebSocket][SERVER] Listening on 0.0.0.0:8765\n</code></pre>"},{"location":"websocket/cli/#send-a-single-frame","title":"Send a single frame","text":"<pre><code>docker-compose run --rm knsock \\\n  websocket send localhost 8765 \"hello from cli\"\n</code></pre> <p>Output:</p> <pre><code>[WebSocket][CLIENT] \u2192 hello from cli\n[WebSocket][CLIENT] \u2190 Echo: hello from cli\n</code></pre>"},{"location":"websocket/cli/#options","title":"Options","text":"Flag Description --headers Additional HTTP headers (key:value) --resource WebSocket path (default /) --timeout Seconds to wait before exit (default\u00a05)"},{"location":"websocket/cli/#positional-arguments","title":"Positional Arguments","text":"Argument Description <code>&lt;host&gt;</code> IP address or hostname of the server <code>&lt;port&gt;</code> Port number to connect to or bind on <code>&lt;message&gt;</code> Message to send (for <code>send</code> command) <p>Note</p> <p>These commands are wrappers around <code>start_websocket_server()</code> and <code>connect_websocket()</code>. For advanced workflows, see Using the Python API.</p>"},{"location":"websocket/cli/#related-topics","title":"Related Topics","text":"<ul> <li>Using the Python API</li> <li>API Reference</li> <li>Testing\u00a0&amp;\u00a0Troubleshooting</li> </ul>"},{"location":"websocket/python-api/","title":"WebSocket Python API","text":"<p>The kn\u2011sock WebSocket API supports both synchronous and asynchronous usage. Use it for custom WebSocket servers, real\u2011time clients, or automation tools.</p>"},{"location":"websocket/python-api/#start-a-websocket-server","title":"Start a WebSocket Server","text":"<pre><code>from kn_sock.websocket import start_websocket_server, WebSocketConnection\nimport threading\n\ndef echo_handler(ws: WebSocketConnection):\n    while ws.open:\n        msg = ws.recv()\n        if msg:\n            ws.send(f\"Echo: {msg}\")\n\nshutdown = threading.Event()\n\nstart_websocket_server(\n    host=\"0.0.0.0\",\n    port=8765,\n    handler=echo_handler,\n    shutdown_event=shutdown\n)\n</code></pre> <p>Use shutdown.set() in another thread to stop the server gracefully.</p>"},{"location":"websocket/python-api/#connect-as-a-client-sync","title":"Connect as a Client (Sync)","text":"<pre><code>from kn_sock.websocket import connect_websocket\n\nws = connect_websocket(\"localhost\", 8765)\nws.send(\"Hello!\")\nprint(ws.recv())  # Echo: Hello!\nws.close()\n</code></pre>"},{"location":"websocket/python-api/#connect-as-a-client-async","title":"Connect as a Client (Async)","text":"<pre><code>import asyncio\nfrom kn_sock.websocket import async_connect_websocket\n\nasync def run():\n    ws = await async_connect_websocket(\"localhost\", 8765)\n    await ws.send(\"Ping\")\n    reply = await ws.recv()\n    print(reply)\n    await ws.close()\n\nasyncio.run(run())\n</code></pre>"},{"location":"websocket/python-api/#notes","title":"Notes","text":"<ul> <li>Both client types return a WebSocketConnection object with .send(), .recv(), and .close() methods.</li> <li>Messages are UTF\u20118 strings.</li> <li>Servers support threading by default.</li> </ul>"},{"location":"websocket/python-api/#related-topics","title":"Related Topics","text":"<ul> <li>Using the CLI</li> <li>API Reference</li> <li>Testing\u00a0&amp;\u00a0Troubleshooting</li> </ul>"},{"location":"websocket/reference/","title":"API Reference","text":"<p>This page documents all public classes and functions available in the <code>kn_sock.websocket</code> module.</p>"},{"location":"websocket/reference/#server","title":"Server","text":""},{"location":"websocket/reference/#kn_sock.websocket.start_websocket_server","title":"<code>start_websocket_server(host: str, port: int, handler: Callable[[WebSocketConnection], None], shutdown_event=None)</code>","text":"<p>Start a blocking WebSocket server using threads per client.</p> <p>Accepts TCP connections, performs a WebSocket handshake, and passes each connected client to the given handler in a new thread.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Bind address (e.g. \"0.0.0.0\").</p> required <code>port</code> <code>int</code> <p>Port number to listen on.</p> required <code>handler</code> <code>Callable</code> <p>Function that receives a WebSocketConnection.</p> required <code>shutdown_event</code> <code>Event</code> <p>Allows graceful shutdown if set.</p> <code>None</code> <p>Raises:</p> Type Description <code>OSError</code> <p>If the socket cannot bind or listen.</p> <code>error</code> <p>On lower-level socket failure.</p> Example <p>def echo(ws): ...     while ws.open: ...         msg = ws.recv() ...         ws.send(f\"Echo: {msg}\") start_websocket_server(\"0.0.0.0\", 8765, echo)</p>"},{"location":"websocket/reference/#sync-client","title":"Sync Client","text":""},{"location":"websocket/reference/#kn_sock.websocket.connect_websocket","title":"<code>connect_websocket(host: str, port: int, resource: str = '/', headers: Optional[dict] = None) -&gt; WebSocketConnection</code>","text":"<p>Connect to a WebSocket server synchronously.</p> <p>Performs a WebSocket handshake and returns a WebSocketConnection.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Server hostname or IP.</p> required <code>port</code> <code>int</code> <p>Port number.</p> required <code>resource</code> <code>str</code> <p>URL path to connect to (default is \"/\").</p> <code>'/'</code> <code>headers</code> <code>dict</code> <p>Additional HTTP headers.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>WebSocketConnection</code> <code>WebSocketConnection</code> <p>A usable connection object.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the handshake fails.</p> <code>error</code> <p>If the connection fails.</p> Example <p>ws = connect_websocket(\"localhost\", 8765) ws.send(\"hello\") print(ws.recv()) ws.close()</p>"},{"location":"websocket/reference/#kn_sock.websocket.WebSocketConnection","title":"<code>WebSocketConnection</code>","text":"<p>Represents a synchronous WebSocket connection.</p> <p>Used for sending and receiving UTF-8 text messages after a successful WebSocket handshake. Typically returned by <code>connect_websocket()</code> or passed to handlers in <code>start_websocket_server()</code>.</p> <p>Methods:</p> Name Description <code>send</code> <p>Send a UTF-8 text message.</p> <code>recv</code> <p>Receive a UTF-8 message.</p> <code>close</code> <p>Gracefully close the connection.</p> <p>Attributes:</p> Name Type Description <code>conn</code> <code>socket</code> <p>The underlying socket object.</p> <code>addr</code> <code>tuple</code> <p>Remote address of the peer.</p> <code>open</code> <code>bool</code> <p>True if the connection is active.</p>"},{"location":"websocket/reference/#kn_sock.websocket.WebSocketConnection.send","title":"<code>send(message: str)</code>","text":"<p>Send a UTF-8 text message over the WebSocket connection.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>The message to send.</p> required <p>Raises:</p> Type Description <code>error</code> <p>If the send operation fails.</p> <code>BrokenPipeError</code> <p>If the connection is already closed.</p> Example <p>ws.send(\"Hello from client\")</p>"},{"location":"websocket/reference/#kn_sock.websocket.WebSocketConnection.recv","title":"<code>recv() -&gt; str</code>","text":"<p>Receive a UTF-8 text message from the WebSocket connection.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The received message, or an empty string if the connection is closed.</p> <p>Raises:</p> Type Description <code>error</code> <p>If receiving fails.</p> <code>UnicodeDecodeError</code> <p>If the received message is not valid UTF-8.</p> Example <p>message = ws.recv() print(message)</p>"},{"location":"websocket/reference/#kn_sock.websocket.WebSocketConnection.close","title":"<code>close()</code>","text":"<p>Close the WebSocket connection gracefully.</p> <p>Sends a close frame and closes the socket.</p> <p>Raises:</p> Type Description <code>error</code> <p>If the socket fails to send the close frame.</p> Example <p>ws.close()</p>"},{"location":"websocket/reference/#async-client","title":"Async Client","text":""},{"location":"websocket/reference/#kn_sock.websocket.async_connect_websocket","title":"<code>async_connect_websocket(host: str, port: int, resource: str = '/', headers: Optional[Dict[str, str]] = None) -&gt; AsyncWebSocketConnection</code>  <code>async</code>","text":"<p>Connect to a WebSocket server asynchronously.</p> <p>Performs a WebSocket handshake and returns an AsyncWebSocketConnection.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Server hostname or IP.</p> required <code>port</code> <code>int</code> <p>Port number.</p> required <code>resource</code> <code>str</code> <p>Path component (default is \"/\").</p> <code>'/'</code> <code>headers</code> <code>dict</code> <p>Additional handshake headers.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>AsyncWebSocketConnection</code> <code>AsyncWebSocketConnection</code> <p>A usable async connection object.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the handshake fails.</p> <code>CancelledError</code> <p>If the coroutine is cancelled mid-connection.</p> Example <p>ws = await async_connect_websocket(\"localhost\", 8765) await ws.send(\"ping\") print(await ws.recv()) await ws.close()</p>"},{"location":"websocket/reference/#kn_sock.websocket.AsyncWebSocketConnection","title":"<code>AsyncWebSocketConnection</code>","text":"<p>Represents an asynchronous WebSocket connection.</p> <p>Used for sending and receiving UTF-8 text messages in asyncio-based clients.</p> <p>Methods:</p> Name Description <code>send</code> <p>Send a message asynchronously.</p> <code>recv</code> <p>Receive a message asynchronously.</p> <code>close</code> <p>Gracefully close the connection.</p> <p>Attributes:</p> Name Type Description <code>reader</code> <code>StreamReader</code> <p>The input stream.</p> <code>writer</code> <code>StreamWriter</code> <p>The output stream.</p> <code>open</code> <code>bool</code> <p>True if the connection is still open.</p>"},{"location":"websocket/reference/#kn_sock.websocket.AsyncWebSocketConnection.send","title":"<code>send(message: str)</code>  <code>async</code>","text":"<p>Send a UTF-8 text message asynchronously.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Message to send.</p> required <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the socket write fails.</p> Example <p>await ws.send(\"Hello async WebSocket\")</p>"},{"location":"websocket/reference/#kn_sock.websocket.AsyncWebSocketConnection.recv","title":"<code>recv() -&gt; str</code>  <code>async</code>","text":"<p>Receive a UTF-8 text message asynchronously.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>The received message, or an empty string on disconnect.</p> <p>Raises:</p> Type Description <code>IncompleteReadError</code> <p>If the socket closes mid-frame.</p> <code>UnicodeDecodeError</code> <p>If the message cannot be decoded.</p> Example <p>message = await ws.recv() print(message)</p>"},{"location":"websocket/reference/#kn_sock.websocket.AsyncWebSocketConnection.close","title":"<code>close()</code>  <code>async</code>","text":"<p>Close the asynchronous WebSocket connection gracefully.</p> <p>Sends a close frame and closes the writer stream.</p> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If the writer fails to send the close frame.</p> Example <p>await ws.close()</p>"},{"location":"websocket/testing/","title":"Testing WebSocket Utilities","text":""},{"location":"websocket/testing/#manual-test","title":"Manual Test","text":"<pre><code># In one terminal, run:\npython3 websocket_server.py\n\n# In another terminal, test with Python:\nfrom kn_sock.websocket import connect_websocket\nws = connect_websocket(\"localhost\", 8765)\nws.send(\"ping\")\nprint(ws.recv())\n</code></pre>"},{"location":"websocket/testing/#automated-test","title":"Automated Test","text":"<pre><code>import threading\nimport time\nfrom kn_sock.websocket import start_websocket_server, connect_websocket\n\ndef echo(ws):\n    while ws.open:\n        msg = ws.recv()\n        if msg:\n            ws.send(msg)\n\ndef test_websocket_echo():\n    shutdown = threading.Event()\n    thread = threading.Thread(\n        target=start_websocket_server,\n        kwargs={\"host\": \"127.0.0.1\", \"port\": 9000, \"handler\": echo, \"shutdown_event\": shutdown},\n        daemon=True\n    )\n    thread.start()\n    time.sleep(0.5)\n    ws = connect_websocket(\"127.0.0.1\", 9000)\n    ws.send(\"test\")\n    assert ws.recv() == \"test\"\n    ws.close()\n    shutdown.set()\n    thread.join(timeout=1)\n\ntest_websocket_echo()\n</code></pre>"},{"location":"websocket/testing/#expected-output","title":"Expected Output","text":"<p>Server terminal: <pre><code>[WebSocket][SERVER] Listening on 0.0.0.0:9000\n[WebSocket][SERVER] Connection from ('172.18.0.1', 33512)\n[WebSocket][SERVER] Received: Hello WebSocket\n</code></pre></p> <pre><code>[WebSocket][SERVER] Listening on 0.0.0.0:9000\n[WebSocket][SERVER] Connection from ('172.18.0.1', 33512)\n[WebSocket][SERVER] Received: Hello WebSocket\n</code></pre> <p>Client terminal: <pre><code>[WebSocket][CLIENT] Connected to ws://172.18.0.2:9000\n[WebSocket][CLIENT] Sent: Hello WebSocket\n[WebSocket][CLIENT] Received: Echo: Hello WebSocket\n</code></pre></p> <p>You can adapt IP addresses or messages as needed, but this serves as a helpful baseline for smoke tests or support.</p>"},{"location":"websocket/testing/#related-topics","title":"Related Topics","text":"<ul> <li>Using the CLI</li> <li>Using the Python API</li> <li>API Reference</li> </ul>"}]}